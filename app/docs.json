{"faq":"# FAQ\n\n### Why did you choose to build on top of Bitcoin?\n\nBitcoin is the blockchain with the most users, the largest market cap, the most amount of software available for it, and the highest amount of security (in terms of the cost of attack). It only makes sense to gravitate to the top blockchain among cryptocurrencies.\n\n### Are you open to building on other blockchains?\n\nYes! While we decided to follow our instincts and build our experimental KV store on the Bitcoin blockchain, we are and have been considering other options like alt-coins, sidechains, and even a Namecoin upgrade. If you have a suggestion and some detailed information about why it makes more sense, please open an issue and we'll discuss.\n\n### How is the Blockstore different from Namecoin?\n\nThis is different from Namecoin in a few fundamental ways:\n\n1. It uses the Bitcoin blockchain, which is the top blockchain. See above.\n2. Rather than store data directly in the Blockchain, this stores the data outside of the blockchain in a DHT. This reduces blockchain bloat and allows for more data to be conveniently stored.\n3. Each namespace has a different pricing scheme for names. That means you can use a namespace with expensive names in order to avoid squatting (ideal for domains), or you can use a namespace with names that cost almost nothing, in order to save money (ideal for non-fungible tokens like trading cards), or you can go for something in the middle (ideal for usernames).\n4. Fees paid to register names go to miners instead of being burned or essentially wasted. This incentivizes mining and increases the overall security of the network.\n\n### Is there a mechanism to store encrypted data?\n\nThere isn't any support for this in this repo. However, to store encrypted data, simply encrypt your file before submitting the data to the blockchain.\n\n### Can't someone just store huge files in the DHT?\n\nNo, we currently cap the size to 8kb. The DHT is not meant for storage of large files (e.g. pictures, videos, etc.) and is only intended for relatively small or moderately sized plaintext files.  Instead, we provide a [storage API](https://github.com/blockstack/blockstore/wiki/Data-Storage) in Blockstore to give users the ability to get, put, and delete large data from storage providers of their choosing.\n\n### Aren't DHTs vulnerable to sybil attacks?\n\nYes. Unfortunately like Bitcoin and other systems, sybil attacks are possible. There is no theoretical solution to sybil attacks, but we take certain practical steps to minimize the effects and risks of this. Also, keep in mind that the only type of attack possible on the DHT is the \"data unavailablity\" attack. Anyone can independently verify that they received the correct data by checking the hash of the data in the blockchain. \n\n### Can nodes just pop in and out and confuse the network?\n\nYes, with nodes entering and exiting a DHT (a process known as churn), the routing tables of the DHT can get affected. The DHT network will recover from this over time, so unless someone is actively attacking the DHT 24/7, occasional churn is going to be largely unnoticeable.\n\n### Is there any incentive to run a node?\n\nNot currently, no.  Only that anyone who turns on the DHT node feature in blockstored is also by default running a full DHT node. If you have any ideas about explicit incentives for running DHT nodes, feel free to reach out!\n\n### Is there a layer on top of the DHT that can make it simpler to grab the data?\n\nAnyone can create a cache of all the DHT data by using the index of the data from the blockchain. We plan on creating such caches (e.g., in memcached servers) and providing easy access to the data through an API. Remember that anyone can verify that the data they received is correct by checking the hash of the data in the blockchain (so you're not trusting the DHT or the cache server).\n\n### Can I build and host my own index/cache of the data in the DHT?\n\nAbsolutely! Anyone can. See above. \n\n### Is OP_RETURN the only way to embed the operation data in the blockchain?\n\nCurrently, yes. However, we recognize the potential to use multi-sig transaction outputs and standard pay-to-pubkey-hash transaction outputs. If you think it's a good idea to add these options, open an issue and we'll discuss it.\n\n### Why do I have to preorder a name before registering it?\n\nIf we didn't require a step before registration, someone could just see that you're broadcasting the registration of a particular name and race you to have their registration included in the next block. By separating the registration into two steps, we're able to support the pre-registration of an undisclosed name followed by the public confirmation of the registration of that name.\n\n### Isn't it essentially free for miners to register names?\n\nNo.  All registration fees, renewal fees, and namespace creation fees are sent to the burn address 1111111111111111111114oLvT2.\n\n### Is there support for names that don't ever expire?\n\nYes. Each namespace has it's own settings, so if you'd like to register names that don't expire, simply use a namespace that has a flag set for non-expiration.\n\n### If my I update my profile daily, my transaction costs will be high. Can I avoid this?\n\nThere are a few ways to avoid this. The first method is to put the somewhat consistent profile data in the main blob, then include a pointer to a JSON file that has the extended data. Profile explorers will read the data in the file as an extension of the main blob, so updating the file will let you update the profile data without issuing a new transaction and updating the hash associated with the name. You can learn more in the openname specifications repo.\n\n### Can a name be owned by a multi-sig address?\n\nAbsolutely. In this system, names are owned by scriptPubKeys, so all scriptPubKey types that Bitcoin supports are supported here.","index":"# Overview\n\nBlockstack is decentralized DNS.\n\nWith the Blockstack software, a network of computers collectively maintain a global registry of domain names.\n\nIn this registry, each of the names has an owner, represented by a cryptographic keypair, and is associated with instructions for how browsers and other software should resolve the name.\n\nAs with the traditional domain name system, the Blockstack domain name system allows users to lookup names, register, renew, and transfer names, as well as manage name resolution information.\n\nBlockstack DNS differs in a few fundamental ways from traditional DNS:\n\n1. While the traditional domain name system is run by an international organization called ICANN, the Blockstack name registry is maintained in a completely decentralized way. It is run by everyone and it is controlled by no one, giving Blockstack DNS incredible and unprecedented technical and sociopolitical resilience.\n2. While traditional DNS relies on a fragile system of disseminating name resolution information, making it vulnerable to DNS cache poisoning, Blockstack DNS has a powerful mechanism for securely transmitting name resolution information that is 100% accurate.\n3. Traditional DNS has no built-in system for securely associating names with cryptographic keypairs. Instead, it relies on a hierarchy of anointed organizations to attest to the ownership of domains, where each organization represents a systemic threat to name resolution security. By comparison, in Blockstack DNS every name is associated with a cryptographic keypair, allowing end-users to trust the authenticity of information sent by servers associated with the name.\n\n## Installation\n\nThe quickest way to get started with Blockstack and get a glimpse of what it can do is to download the command line interface and perform a name lookup.\n\nInstalling the Blockstack command line interface is simple:\n\nOS X / Mac:\n\n    $ brew install blockstack\n\nLinux\n\n    $ apt-get install blockstack\n\nSee the installation docs for more:\n\n[Installation](/docs/installation)\n\n## Lookups\n\nNow, to perform a name lookup, run this command:\n\n    $ blockstack lookup fredwilson.id\n\nYou should get a response like this:\n\n\n    {\n      \"address\": \"16EMaNw3pkn3v6f2BgnSSs53zAKH4Q8YJg\",\n      \"creation\": {\n        \"consensus_block_id\": 373600,\n        \"consensus_hash\": \"17ac43c1d8549c3181b200f1bf97eb7d\",\n        \"type\": \"NAME_IMPORT\"\n      },\n      \"serial_number\": \"373622-63\",\n      \"zone_file\": {\n        \"$origin\": \"fredwilson.id\",\n        \"$ttl\": \"3600\",\n        \"txt\": [{ \"name\": \"@\", \"txt\": \"https://s3.amazonaws.com/zk9/fredwilson.id\" }]\n      }\n    }\n\n[Lookups](/docs/lookups)\n\n## Registrations\n\nAfter you get comfortable with looking up names, take the next step and register and manage a name for yourself. Run the following command:\n\n\n    $ blockstack register <my_awesome_name>.id <ecdsa_private_key>\n\nIf the name hasn’t been registered yet, you’ll get a confirmation that your registration is pending:\n\n\n    {\n      \"success\": True,\n      \"error\": None\n    }\n\nAfter a few hours, your registration should go through and you’ll be able to update your DNS records for the name.\n\n[Registrations](/docs/registrations)\n\n## More\n\nSee the usage section for more information, as well as all the other articles in the sidebar.\n\nIf you’re an application developer, check out the app developer guide; if you’re a systems developer, check out the contributor guide; and if you just want to see how Blockstack works in deeper detail, head over to the technical writeup section.\n\nEnjoy using Blockstack and we can’t wait to see what you build on it and where it takes you.\n","installation":"# Installation\n\nThis page is meant to walk you through installing and starting up Blockstore for the first time.\n\n### Requirements\n\n- [x] Acccess to a bitcoin node with a full transaction index (i.e. txindex is\nenabled). You need to be able to connect to a specific bitcoin node that stores\neach transaction. Note: This is ​*not*​ the default behavior, the `txindex` option\nhas to be explicitly enabled in the node.  For example, `btcd.onename.com` has\nthis feature enabled.\n- [x] [Python 2.6 or higher](https://www.python.org/). (Python 3.x not supported)\n- [x] Python 2.x development headers (in most Linux distributions, this is usually the `python-dev` or `python-devel` package).\n- [x] [The Python distutils package](https://docs.python.org/2/distutils/) (Verify\nas it is not always installed with Python)\n- [x] [Python pip](https://pypi.python.org/pypi/pip)\n\n### Installing with pip\n\nTo install Blockstore from the (Python Package Index)[https://pypi.python.org/pypi], you can use the following command:\n\n```\n$ pip install blockstore\n```\n\nThis will install Blockstore, and all of its dependencies.\n\n### Installing from Source\n\nWe use distutils to package Blockstore, and provide a setup.py script to pull in additional dependencies.  The package is built with:\n\n```\n$ python setup.py build\n```\n\nTo install blockstored and all of its dependent packages, run:\n\n```\n$ sudo python setup.py install\n```\n\n### Running Blockstore for the First Time\n\nWhen you run Blockstore for the first time, you will be prompted for some basic configuration information.  In particular, Blockstore will need to know how to connect to your bitcoin node, and how to connect to a Bitcoin API provider.  By default, Blockstore will connect to the Bitcoin node fleet that Onename maintains.\n\nConnecting to a bitcoin node is just a matter of supplying Blockstore with the server, port, and login information.  Blockstore will pull transactions and data from it to reconstruct the name database locally.  In particular, Blockstore prompts for:\n\n* `user`: the bitcoin's RPC username (akin to `-rpcuser` in bitcoin-cli).  It defaults to `openname`.\n* `passwd`: the bitcoin's RPC password (akin to `-rpcpassword` in bitcoin-cli).  It defaults to `opennamesystem`.\n* `server`: the name or IP address of the bitcoin node (akin to `-rpcconnect` in bitcoin-cli).  It defaults to `btcd.onename.com`.\n* `port`: the RPC port number of the bitcoin node (akin to `-rpcport` in bitcoin-cli).  It defaults to `8332`.\n* `use_https`: whether or not to use SSL.  If you are unsure, type `True`.  It defaults to `True`.\n\nBlockstore needs to access [unspent outputs](https://bitcoin.org/en/glossary/unspent-transaction-output) (UTXOs) to create transactions. Bitcoind does not track UTXOs for all Bitcoin addresses, therefore blockstore needs access to a full UTXO index. Blockstore currently has the option to specify an API provider for accessing UTXOs and users don't need to deploy a UTXO index/database themselves. The API provider gets used to find unspent outputs and also for broadcasting transactions.  Blockstore comes with API support for:\n\n* [Blockcypher](http://www.blockcypher.com/)\n* [chain.com](http://chain.com)\n* [blockchain.info](https://blockchain.info)\n* A bitcoin node configured to track UTXOs\n\nYou will be prompted to select one of the four.  In the case of chain.com, Blockcypher, and blockchain.info, you will need to obtain an API token.  The details of how to go about doing so can be found at each of the websites above.  Blockchain.info and Blockcypher currently offer free API tokens.\n\nOnce you have chosen your API provider and have an API token, Blockstore will prompt you for them.  After you have entered all of the requisite information, Blockstore will save its configuration to `~/.blockstore/blockstore.ini` for future use.  \n\n#### Example\n\nBelow is an example trace of running `blockstored` for the first time.  The user selected the default options for connecting to the Bitcoin network, and selected Chain.com as the API provider.  The API token is redacted.\n\n```\n$ ./blockstored start\n--------------------------------------------------------\nBlockstore does not have enough information to connect\nto bitcoind.  Please supply the following parameters, or\npress [ENTER] to select the default value.\n--------------------------------------------------------\npasswd (default: 'opennamesystem'): \nport (default: '8332'): \nuser (default: 'openname'): \nuse_https (default: 'True'): \nserver (default: 'btcd.onename.com'): \n--------------------------------------------------------\nNOTE: Blockstore currently requires an external API\nfor querying unspent transaction outputs.  The set of\nsupported providers are:\nchain_com       \nblockcypher     \nblockchain_info \nbitcoind_utxo\nPlease get the requisite API tokens and enter them here.\n--------------------------------------------------------\nutxo_provider: chain_com\n-----------------------------------------------\nPlease enter your chain.com API key and secret.\n-----------------------------------------------\napi_key_id: *********\napi_key_secret: ********\n```\n\n### Administrating Blockstore\n\nOnce you have configured blockstore, you will subsequently be able to start it with:\n\n```\n$ blockstored start \n```\n\nTo stop blockstore, simply run:\n\n```\n$ blockstored stop\n```\n\nBy default, blockstore will synchronize its database with the blockchain, and then become a daemon and serve RPC requests in the background.  If you want it to run in the foreground, simply pass `--foreground` with the `start` option (example: `blockstored start --foreground`).  By default, blockstore will log RPC requests to `~/.blockstore/blockstore.log.access` and blockchain indexing debug messages to `~/.blockstore/blockstore.log.indexer`.","lookups":"# Lookups\n\nThis page describes how to look up information on a name.  You will need to have installed [blockstore-client](https://github.com/blockstack/blockstore-client), and have access to a full Blockstore node.\n\n### Getting a Name's Data\n\nUsers use Blockstore to securely associate data with their names.  The data itself is stored externally in a DHT, but the hash and some metadata is embedded in the underlying blockchain.  To fetch the *data*, the command format is as follows:\n\n```\n$ blockstore-cli lookup <name>\n```\n\nUpon successful execution, the command will print out a JSON object with the following fields:\n\n* `address`: the base58-encoded hash of the name owner's public key (i.e. their Bitcoin address).\n* `creation`: this is a JSON object with the following fields:\n   * `consensus_hash`: This is the consensus hash for this name's import or preorder.  If the name was imported, the consensus hash comes from the namespace preorder transaction in the blockchain.  If the name was preordered, the consensus hash comes from the preorder transaction in the blockchain.\n   * `consensus_block_id`: This is the block number for the above consensus hash.\n   * `type`:  This is either \"NAME_PREORDER\" if the name was preordered, or \"NAME_IMPORT\" if the name was imported.  It indicates how to interpret the above consensus hash and block number.\n* `serial_number`: this is the globally-unique identifier for the name.\n* `zone_file`: this is the data associated with the name, fetched from the DHT.  The contents of this field are arbitrary, but it is usually a JSON document.\n\nIf the name was since updated, it will also have a `modified` field in addition to the `creation` field.  The `modified` field contains the exact same structure, but with values reflecting the most recent update or transfer.\n\nOn error, the command will print out a JSON object with an `error` field.\n\n#### Example\n\nIn this example, we look up the data associated with the name `judecn.id`.  The associated data just happens to be a JSON document in this case, but the data can be anything at all in practice.\n\n```\n$ blockstore-cli lookup judecn.id         \n{\n    \"address\": \"16EMaNw3pkn3v6f2BgnSSs53zAKH4Q8YJg\",\n    \"creation\": {\n        \"consensus_block_id\": 373600,\n        \"consensus_hash\": \"17ac43c1d8549c3181b200f1bf97eb7d\",\n        \"type\": \"NAME_IMPORT\"\n    },\n    \"serial_number\": \"373622-63\",\n    \"zone_file\": {\n        \"avatar\": {\n            \"url\": \"https://s3.amazonaws.com/kd4/judecn\"\n        },\n        \"bio\": \"PhD student\",\n        \"bitcoin\": {\n            \"address\": \"17zf596xPvV8Z8ThbWHZHYQZEURSwebsKE\"\n        },\n        \"cover\": {\n            \"url\": \"https://s3.amazonaws.com/97p/gQZ.jpg\"\n        },\n        \"facebook\": {\n            \"proof\": {\n                \"url\": \"https://facebook.com/sunspider/posts/674912239245011\"\n            },\n            \"username\": \"sunspider\"\n        },\n        \"github\": {\n            \"proof\": {\n                \"url\": \"https://gist.github.com/jcnelson/70c02f80f8d4b0b8fc15\"\n            },\n            \"username\": \"jcnelson\"\n        },\n        \"location\": {\n            \"formatted\": \"Princeton University\"\n        },\n        \"name\": {\n            \"formatted\": \"Jude Nelson\"\n        },\n        \"twitter\": {\n            \"proof\": {\n                \"url\": \"https://twitter.com/judecnelson/status/507374756291555328\"\n            },\n            \"username\": \"judecnelson\"\n        },\n        \"v\": \"0.2\",\n        \"website\": \"http://www.cs.princeton.edu/~jcnelson\"\n    }\n}\n```\n\nHere is an example of a lookup on a user that does not exist:\n\n```\n$ blockstore-cli lookup nonexistent.id\n{\n    \"error\": \"Not found.\"\n}\n```\n\n### Getting a Name's Metadata\n\nThe blockchain itself stores some metadata for each name, which Blockstore tracks separately.  The metadata includes information such as a name's update history, the locations in the blockchain at which the name was altered, and so on.  The command format is as follows:\n\n```\n$ blockstore-cli get_name_blockchain_record <name>\n```\n\nOn success, the command prints out a JSON object that contains all the information Blockstore learned about this name from the underlying blockchain.  See the \"Reading and Writing Name Profiles\" section in the [Usage](https://github.com/blockstack/blockstore/wiki/Usage) document for an overview of what each of the fields mean.\n\nIf this command fails, it prints out a JSON object with an `error` key, as well as an associated error message.\n\n#### Example\n\nIn this example, we look up the blockchain metadata for the name `judecn.id`\n\n```\n$ blockstore-cli get_name_blockchain_record judecn.id\n{\n    \"address\": \"16EMaNw3pkn3v6f2BgnSSs53zAKH4Q8YJg\",\n    \"block_number\": 373622,\n    \"first_registered\": 373622,\n    \"history\": {\n        \"373622\": [\n            {\n                \"address\": \"16firc3qZU97D1pWkyL6ZYwPX5UVnWc82V\",\n                \"fee\": 38500,\n                \"history_snapshot\": true,\n                \"importer\": \"76a9143e2b5fdd12db7580fb4d3434b31d4fe9124bd9f088ac\",\n                \"importer_address\": \"16firc3qZU97D1pWkyL6ZYwPX5UVnWc82V\",\n                \"name\": \"judecn.id\",\n                \"opcode\": \"NAME_IMPORT\",\n                \"recipient\": \"76a914caee018147f2d5ff32ca3b2ef35c17755bce440e88ac\",\n                \"recipient_address\": \"1KVzcgurJmTr4Cr44h6raEVtoGhm7ZZxzm\",\n                \"sender\": \"76a9143e2b5fdd12db7580fb4d3434b31d4fe9124bd9f088ac\",\n                \"sender_pubkey\": \"0411d88aa37a0eea476a5b63ca4b1cd392ded830865824c27dacef6bde9f9bc53fa13a0926533ef4d20397207e212c2086cbe13db5470fd29616abd35326d33090\",\n                \"txid\": \"c698ac4b4a61c90b2c93dababde867dea359f971e2efcf415c37c9a4d9c4f312\",\n                \"value_hash\": \"dbbdedc2b81d875403cc76486625a19f1e3b3c6f\",\n                \"vtxindex\": 63\n            }\n        ],\n        \"374075\": [\n            {\n                \"address\": \"1KVzcgurJmTr4Cr44h6raEVtoGhm7ZZxzm\",\n                \"importer\": \"76a9143e2b5fdd12db7580fb4d3434b31d4fe9124bd9f088ac\",\n                \"importer_address\": \"16firc3qZU97D1pWkyL6ZYwPX5UVnWc82V\",\n                \"sender\": \"76a914caee018147f2d5ff32ca3b2ef35c17755bce440e88ac\",\n                \"sender_pubkey\": \"0411d88aa37a0eea476a5b63ca4b1cd392ded830865824c27dacef6bde9f9bc53fa13a0926533ef4d20397207e212c2086cbe13db5470fd29616abd35326d33090\",\n                \"txid\": \"c698ac4b4a61c90b2c93dababde867dea359f971e2efcf415c37c9a4d9c4f312\",\n                \"value_hash\": \"dbbdedc2b81d875403cc76486625a19f1e3b3c6f\",\n                \"vtxindex\": \"63\"\n            }\n        ],\n        \"383270\": [\n            {\n                \"address\": \"1KVzcgurJmTr4Cr44h6raEVtoGhm7ZZxzm\",\n                \"importer\": \"76a9143e2b5fdd12db7580fb4d3434b31d4fe9124bd9f088ac\",\n                \"importer_address\": \"16firc3qZU97D1pWkyL6ZYwPX5UVnWc82V\",\n                \"sender\": \"76a914caee018147f2d5ff32ca3b2ef35c17755bce440e88ac\",\n                \"sender_pubkey\": \"0411d88aa37a0eea476a5b63ca4b1cd392ded830865824c27dacef6bde9f9bc53fa13a0926533ef4d20397207e212c2086cbe13db5470fd29616abd35326d33090\",\n                \"txid\": \"7cfdfcf0c0abac9641ed5e253e7ba2b3ddabbc0b15302a4fc138519dd028d3ea\",\n                \"value_hash\": \"dbbdedc2b81d875403cc76486625a19f1e3b3c6f\",\n                \"vtxindex\": 234\n            }\n        ]\n    },\n    \"importer\": \"76a9143e2b5fdd12db7580fb4d3434b31d4fe9124bd9f088ac\",\n    \"importer_address\": \"16firc3qZU97D1pWkyL6ZYwPX5UVnWc82V\",\n    \"last_renewed\": 373622,\n    \"name\": \"judecn.id\",\n    \"op\": \";\",\n    \"op_fee\": 100000.0,\n    \"opcode\": \"NAME_IMPORT\",\n    \"preorder_block_number\": 373622,\n    \"revoked\": false,\n    \"sender\": \"76a914395f3643cea07ec4eec73b4d9a973dcce56b9bf188ac\",\n    \"sender_pubkey\": \"0411d88aa37a0eea476a5b63ca4b1cd392ded830865824c27dacef6bde9f9bc53fa13a0926533ef4d20397207e212c2086cbe13db5470fd29616abd35326d33090\",\n    \"txid\": \"1510e1582f48c7ea1c57156e6ac5ae0d2c0960cfb4d17db0860e140f6900beed\",\n    \"value_hash\": \"dbbdedc2b81d875403cc76486625a19f1e3b3c6f\",\n    \"vtxindex\": 108\n}\n```\n\nIn this example, we look up a name that does not exist:\n\n```\n$ blockstore-cli get_name_blockchain_record nonexistent.id\n{\n    \"error\": \"Not found.\"\n}\n```\n\n### Listing Names\n\nBlockstore can serve a listing of all the name metadata it knows about.  To do so, the command is:\n\n```\n$ blockstore-cli get_all_names\n```","namespaces":"# Namespaces\n\nBlockstore organizes names into namespaces.  A name's namespace can be identified by looking at the characters after the last '.' in the name.\n\n### Creating a Namespace\n\nCreating a namespace is a 4-step process:\n\n* Preordering a namespace\n* Revealing a namespace \n* Importing names into the namespace \n* Opening the namespace for registration\n\nBefore the namespace is open for registration, the namespace creator has the power to define the namespace ID, its pricing parameters, and add an initial set of names.  Once the namespace is opened for registration, anyone can create names within the namespace, subject to pricing and availability.\n\nJust as how Blockstore requires name owners to preorder and then register a name, it also requires namespace creators to preorder and then reveal namespaces.  Preordering a namespace requires the namespace creator to have two key pairs: one for preordering the namespace, and one for revealing it.  The reason for this is to stop a would-be namespace squatter from stealing the namespace as it is revealed--by design, the squatter cannot see the name of the namespace until after it has been preordered.  As such, it is important that the revealing key pair be *known only to the namespace creator*.\n\nThe command to pre-order a namespace is:\n\n```\n$ blockstore-cli namespace_preorder <namespace ID> <preorder private key> <reveal_address>\n```\n\n#### Example\n\nThe following command will preorder the namespace `abc`, granting control of the name to the private key tied to the `reveal_address` (the 3rd argument).\n\n```\n$ blockstore-cli namespace_preorder abc 5KMKzs7grgyatKURCgxB7SgdeYu35poaEumJShLxPpLTBCrpy8o 199VaCaC9p95otia9e2EH7i6yZq7EWJHk2\n```\n\nNote that the address of `5KMKzs7grgyatKURCgxB7SgdeYu35poaEumJShLxPpLTBCrpy8o` is `1HYWB9R8ZKXVfEUstJAPhdkJ3nRpc2KHCM`, while the private key of address `199VaCaC9p95otia9e2EH7i6yZq7EWJHk2` is actually `5JZAZzZo5JvCEc4x9pkNAdkLf468H4KVMMhrwcv6WKFJ9x3ZC7m`.  Address `1HYWB9R8ZKXVfEUstJAPhdkJ3nRpc2KHCM` will be charged 40 BTC (sent to the burn address `1111111111111111111114oLvT2`), plus mining fees and dust fees.\n\nThe result of the command will contain the transaction ID in Bitcoin, which the namespace creator can monitor to ensure that the rest of the Bitcoin network accepts the preorder transaction.  We advise the namespace creator to wait for six confirmations before the revealing the namespace.\n\n### Revealing a Namesace\n\nOnce a namespace has been preordered, the creator (and only the creator) can reveal it.  In doing so, the creator sets the lifetime for each name in the namespace, as well as all of the pricing parameters (K, B, N, V, and A).\n\n**Caveat**: Once a namespace is revealed, its properties are set forever.\n\nThe command to do so is:\n\n```\n$ blockstore-cli namespace_reveal <namespace ID> <reveal_address> <lifetime_in_blocks> <K> <B> <N> <A> <V> <preorder private key>\n```\n\nThe cost of revealing a namespace is simply the mining fee plus the dust fees for each output.\n\n#### Example\n\nSuppose the namespace creator of `abc` wanted each name to cost at least 200 uBTC, and for name prices to vary by powers of 10.  Suppose that the desired pricing rule was that all names between lengths 1 and 10 would cost 20 BTC, and all names greater than length 8 would cost 2 BTC.  Suppose that names could receive a 50-fold discount if they had no vowels, and a 100-fold discount if they had numbers or punctuation.  Suppose also that names were supposed to expire after 3 years.  To reveal the namespace with these properties, the namespace creator would issue the command:\n\n```\n$ blockstore-cli namespace_reveal abc 199VaCaC9p95otia9e2EH7i6yZq7EWJHk2 157788 200 10 4,4,4,4,4,4,4,4,3,3,3,3,3,3,3,3 100 50 5KMKzs7grgyatKURCgxB7SgdeYu35poaEumJShLxPpLTBCrpy8o\n```\n\n### Importing Names\n\nAfter the namespace is revealed, the namespace creator has the opportunity to populate the namespace with names.  In doing so, the creator registers the name for a particular address and assigns it the hash of its profile.  This way, when the namespace is ready for registration, the names are already owned by their respective owners.\n\nThe command to import a name is:\n\n```\n$ blockstore-cli name_import <name.namespace> <name owner's address> <name owner's profile hash> <name revealer private key>\n```\n\nThe fourth argument is the private key meant for revealing names, whose address was used as the revealer address when preordering and revealing the namespace.  This private key is *not* the one used to preorder and reveal the namespace.\n\nThe cost of importing names is just the cost of the mining fees, plus the dust cost for each output.  Importantly, the namespace creator does *not* pay the name's price when importing names.\n\n#### Example\n\nSuppose the creator of `abc` wanted to import the name `swiftonsecurity.abc`, and have it be owned by the owner of the address `199VaCaC9p95otia9e2EH7i6yZq7EWJHk2`.  Suppose the owner had a name profile with hash `8b3fe3a9ecb162cb7968d5a889fbf159c9f317cb`.  To import this name, the namespace creator would issue the command:\n\n```\n$ blockstore-cli name_import swiftonsecurity.abc 199VaCaC9p95otia9e2EH7i6yZq7EWJHk2 8b3fe3a9ecb162cb7968d5a889fbf159c9f317cb 5JZAZzZo5JvCEc4x9pkNAdkLf468H4KVMMhrwcv6WKFJ9x3ZC7m\n```\n\nThen, when the namespace is ready, only the owner of `199VaCaC9p95otia9e2EH7i6yZq7EWJHk2` will be able to update, transfer, or revoke the name `swiftonsecurity.abc`.\n\n### Notes on Importing Names\n\n* A namespace must be ready no later than 52596 blocks after they are revealed.  Otherwise, it expires, as well as all of its imported names.  Namespace creators should calculate how long it will take to import all names *before* creating the namespace.\n* Sometimes, there can be a lot of names to reveal at once, and revealing them all in sequence can be prohibitively time-consuming.  To address this, Blockstore will accept name imports that have come from one of up to 300 unhardened hierarchical deterministic (HD/BIP32) key pairs derived from the name revealer private key.  Each key pair's wallet can be loaded with BTC, and each used to import a disjoint subset of names concurrently.\n* Sometimes, the namespace creator will need to update an already-imported name.  For example, the name owner might disagree with the namespace creator as to what the hash of the profile is.  To address this, Blockstore honors the *last-seen* copy of a name import whenever there is a conflict.  The namespace creator can overwrite old name imports this way until the namespace is declared ready.\n\n### Making the Namespace Ready\n\nOnce the namespace creator is satisfied with the state of the namespace, it can be made ready for registration by the public.  Once this happens, the namespace creator will no longer have the power to alter the set of names in the namespace, except for the ones (s)he owns (and (s)he is limited to 25 names by the Blockstore implementation).\n\nIn order to make the namespace ready, the namespace creator issues the `namespace_ready` command:\n\n```\n$ blockstore-cli namespace_ready <namespace ID> <revealer private key>\n```\n\nNote that the private key is the *revealer* private key, not the preorder pirvate key.\n\nOnce accepted and recognized by Blockstore, the namespace will be open for registration--anyone will be able to preorder and register currently-unclaimed names.\n\nThe cost of making a namespace ready is simply the mining fee plus the dust cost of each output.\n\n#### Example\n\nTo make the namespace `abc` ready, the namespace creator would run:\n\n```\n$ blockstore-cli namespace_ready abc 5JZAZzZo5JvCEc4x9pkNAdkLf468H4KVMMhrwcv6WKFJ9x3ZC7m\n```","pricing":"# Pricing\n\nNamespaces exist to set fees and lifetimes for the sets of names they contain.  Namespace prices are characterized by orders of magnitude, determined by the namespace's creator.  To price names, each namespace defines a set of 16 price \"buckets\" that characterize the order of magnitude of the price of of 1-character names, 2-character names, etc., with the 16th bucket serving as a catch-all for names with at least 16 characters.  The absense of vowels and the presence of non-alpha characters add multiplicative discounts to the name's price.  The price is calculated as follows:\n\n* Let `B` be the namespace's \"base price\".\n* Let `K` be the namespace's constant price multiplier.\n* Let `L` be the length of the name.\n* Let `N[L-1]` be the bucket that the name falls into (i.e. the price's order of magnitude).\n* Let `V` be the discount for having no vowels (it is set to 1 for names with vowels).\n* Let `A` be the discount for having non-alphabet characters (it is set to 1 for names with only alphabetical characters).\n\nThen, the price of a name is calculated as `(K * (B ** N[L-1])) / (max([1, V, A]))`.  The units are in uBTC.\n\n#### Example\n\nThe pricing of the `id` namespace (specified in Bitcoin transaction `ab54b1c1dd5332dc86b24ca2f88b8ca0068485edf0c322416d104c5b84133a32`) is as follows:\n\n* K = 250 \n* B = 4 \n* N = [6, 5, 4, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n* V = 10\n* A = 10\n\nThen, the following prices hold:\n\n* The price of `a.id` is `(250 * (4**6)) / (max([1, 1, 1])) = 1024000 uBTC`, or 1.024 BTC.\n* The price of `1.id` is `(250 * (4**6)) / (max([1, 10, 10])) = 102400 uBTC`, or 0.1024 BTC.\n* The price of `abc.id` is `(250 * (4**4)) / (max([1, 1, 1])) = 64000 uBTC`, or 0.064 BTC.\n* The price of `bcd.id` is `(250 * (4**4)) / (max([1, 10, 1])) = 6400 uBTC`, or 0.0064 BTC.\n* The price of `judecn.id` is `(250 * (4**1)) / (max([1, 1, 1]) = 1000 uBTC`, or 0.001 BTC.\n* The price of `j00dcn.id` is `(250 * (4**1)) / (max([1, 10, 10]) = 100 uBTC`, or 0.0001 BTC.\n* The price of `swiftonsecurity.id` is `(250 * (4**0)) / min([1, 1, 1])` = 250 uBTC, or 0.00025 BTC.\n\n### Namespace Pricing\n\nNamespaces are not free; their price is a function of their length.  Blockstore enforces the following pricing rules on creating namespaces:\n\nNamespace ID length | Cost (in BTC)\n------------------- | -------------:\n1                   | 400.0\n2, 3                | 40.0\n4, 5, 6, 7          | 4.0 \n8 and up            | 0.4\n\nNamespace creation fees are sent to the Blockstore burn address (`1111111111111111111114oLvT2`).  The price of a namespace can be queried with `blockstore-cli` via the `get_namespace_cost` command:\n\n```\n$ blockstore-cli get_namespace_cost <namespace ID>\n```","registrations":"# Registrations\n\nRegistering a new name is a two-step process:  it must first be *preordered*, and then *registered.*  Only the principal who preordered the name can register it.  This is done as an anti-squatting measure, in order to stop someone from stealing a name while it is being propagated through the network.\n\nA name owner can have multiple names.  The current limit is 25 per key pair, but this is arbitrary.\n\nEach name in Blockstore is part of a *namespace*.  The name identifies the namespace it belongs to by ending in \".<namespace ID>\".  For example, the name `swiftonsecurity.id` belongs to the `id` namespace.\n\nIn order to register a name, the namespace must exist and be open to name registration.  You can confirm this with the `get_namespace_blockchain_record` command, as follows:\n\n```\n$ blockstore-cli get_namespace_blockchain_record <namespace ID>\n```\n\nThis command will succeed only if the namespace is ready.  More details on namespaces can be found in the **Namespaces** section.\n\n### Name Preorders\n\nTo preorder a name, a name owner needs *two* sets of key pairs:  one to preorder, and one to register.  The *second* key pair should be brand-new and known only to the name owner.  The second key pair's address does not need any Bitcoin, but the name owner will need to transfer some to it once it is necessary to update the name's profile.  The secrecy of the second key pair is important, because Blockstore uses its address as a cryptographic hash salt to blind would-be name squatters.  Once registered, the name will be controlled by the *second* key pair.\n\nThe name owner pays for the name by preordering it using the *first* key pair, since only the name owner will be able to claim it.  The amount paid can be determined with the `get_name_cost` command:\n\n#### Example\n\n```\n$ ./blockstore-cli get_name_cost swiftonsecurity.id\n[\n    {\n        \"satoshis\": 25000\n    }\n]\n```\n\nThe fee will be sent from the address of the private key used to preorder the name.\n\nOnce the name owner has found a suitably-priced name, the `preorder` command can be used to preorder it.  It is used as follows:\n\n```\n$ blockstore-cli preorder <name.namespace> <preorder_privatekey> <register_address>\n```\n\nOnce preordered, the name owner must register the name within 144 blocks of the preorder (about 24 hours).\n\n#### Example\n\nThe following command will preorder the name `swiftonsecurity.id`, granting control of the name to the private key tied to the `register_address` (the 3rd argument).\n\n```\n$ blockstore-cli preorder swiftonsecurity.id 5KMKzs7grgyatKURCgxB7SgdeYu35poaEumJShLxPpLTBCrpy8o 199VaCaC9p95otia9e2EH7i6yZq7EWJHk2\n```\n\nNote that the address of `5KMKzs7grgyatKURCgxB7SgdeYu35poaEumJShLxPpLTBCrpy8o` is `1HYWB9R8ZKXVfEUstJAPhdkJ3nRpc2KHCM`, while the private key of address `199VaCaC9p95otia9e2EH7i6yZq7EWJHk2` is actually `5JZAZzZo5JvCEc4x9pkNAdkLf468H4KVMMhrwcv6WKFJ9x3ZC7m`.  Address `1HYWB9R8ZKXVfEUstJAPhdkJ3nRpc2KHCM` will be charged 25000 satoshis (sent to the burn address `1111111111111111111114oLvT2`), plus mining fees and dust fees.\n\nThe result of the command will contain the transaction ID in Bitcoin, which the name owner can monitor to ensure that the rest of the Bitcoin network accepts the preorder transaction.  We advise the name owner to wait for six confirmations before the registering the name.\n\n### Name Registrations\n\nThe name owner should wait for at least six transaction confirmations to ensure that the preorder was accepted.  Once it has been accepted, the name owner must use the preorder key pair to register the name, and reveal the address of the new public key that will control it.\n\nThis is achieved with the `register` command:\n\n```\n$ blockstore-cli register <name.namespace> <preorder_privatekey> <register_address> \n```\n\nThis will create an empty profile for the name owner, and reveal to the world the name owner's new name, Bitcoin address, and preorder public key.\n\n#### Example\n\nTo register the preordered name `swiftonsecurity.id`, the name owner would run the following command:\n\n```\n$ blockstore-cli register swiftonsecurity.id 5KMKzs7grgyatKURCgxB7SgdeYu35poaEumJShLxPpLTBCrpy8o 199VaCaC9p95otia9e2EH7i6yZq7EWJHk2\n```\n\nThe result of the command will contain the transaction ID in Bitcoin, which the name owner can monitor to ensure that the rest of the network accepts the register transaction.  The cost of registering is simply the cost of the mining fee and dust fees for each output.","renewals":"# Renewals\n\nIn most namespaces, names have finite lifetimes and will eventually expire.  Exactly when is determined by the rules of the namespace, but a name is be said to have expired by a certain block number.  After this point, the name can be preordered and registered by someone else.  If the name owner wants to avoid this, the name must be *renewed*.\n\nWhen a name is renewed, its lifetime is reset to the maximum lifetime defined by the namespace.  Some namespaces allow names to have infinite lifetimes, in which case no renewal is necessary.\n\nThe fee to renew the name is determined by the rules of the namespace, but it is the same fee paid at registration.  The cost to renew can be obtained with the `get_name_cost` operation as before.\n\nThe following command invocation will renew a name:\n\n```\n$ blockstore-cli renew <name.namespace> <name owner&#39;s private key>\n```\n\n#### Example\n\nThis command will renew the name `swiftonsecurity.id`.  The owner of the address `199VaCaC9p95otia9e2EH7i6yZq7EWJHk2` will continue to own it for another 52595 blocks.\n\n```\n$ blockstore-cli renew swiftonsecurity.id 5JZAZzZo5JvCEc4x9pkNAdkLf468H4KVMMhrwcv6WKFJ9x3ZC7m\n```\n\nNote that the private key used has the address `199VaCaC9p95otia9e2EH7i6yZq7EWJHk2`, which is the registration address used in the earlier example (not to be confused with the preorder pair).","transfers":"# Transfers\n\nThis page shows how to transfer a name to a new owner.  You will need to have installed the [blockstore-client](https://github.com/blockstack/blockstore) package, and will need access to a full Blockstore node.\n\n**WARNING:** Transferring a name cannot be undone.  Once transferred, only the new owner will be able to transfer it.\n\n### Requirements\n\nTo transfer a name to a new owner, you will need:\n\n* your private key\n* the recipient's address\n\n### Transferring\n\nThe command format to transfer a name is as follows:\n\n```\n$ blockstore-cli transfer <name.namespace> <recipient address> <keep data?> <privatekey>\n```\n\nYou have the option to transfer your profile data to the new owner, as well as the name.  This is controlled by typing `True` or `False` into the `<keep data?>` field.  If you are unsure, you should pass `False`.  This is because it is **not** recommended that you transfer your profile, since the new name owner could use it to impersonate you.\n\nWhen the command runs successfully, it will return a JSON object with at least the following fields given:\n\n```\n{\n   \"transaction_hash\": <the transaction ID on the blockchain that contains this transfer>\n   \"data\": <the OP_RETURN data>\n}\n```\n\nOn error, an `error` field will be present, and it will contain a descriptive error message.\n\n#### Example\n\nSuppose the owner of `swiftonsecurity.id` wanted to transfer her name (but **not** her profile data) to the address `1NMkY7MThPGWgrHZWfp6uwP5PqyfF8i86R`.  Suppose that her private key is `5JZAZzZo5JvCEc4x9pkNAdkLf468H4KVMMhrwcv6WKFJ9x3ZC7m`.  Then, to do so, she would run:\n\n```\n$ blockstore-cli transfer swiftonsecurity.id 1NMkY7MThPGWgrHZWfp6uwP5PqyfF8i86R False 5JZAZzZo5JvCEc4x9pkNAdkLf468H4KVMMhrwcv6WKFJ9x3ZC7m\n```\n\nIf the command succeeds, it might print something like this:\n\n```\n{\n    \"transaction_hash\": \"269874f5a3847e0e869c982b5edfcb3a77b26f04dcfcfc0bdf1c75cf8fbacf35\", \n    \"data\": \"69643e7e7727f568dd9d36d5c777c024da599473a94e23658c0ee8424b78034cc72ebbb7\"\n}\n```\n\n### Interpreting the OP_RETURN data\n\nIf you look closely at `data`, you'll see that the first four bytes (`69643e7e`) decode to the ASCII string `id>~`.  This specifically indicates a `NAME_TRANSFER` operation (represented by `id>`), where the profile data was *not* preserved (represented by `~`).  Had the user passed `True`, then the first four bytes would be `69643e3d`, or `id>>` in ASCII (where the second `>`) indicates that the profile record should be preserved\n\n### Troubleshooting\n\nThe only way this command can fail is if there was a blockchain-level problem.  If the transaction did not go through to the underlying blockchain, follow the advice in the \"Rejected Transactions\" section of [[Commands don't Work]].\n\n### Name was sent to the wrong address\n\nUnfortunately, there is nothing to do but wait for the name to expire.  The fact that Blockstore prevents other users from taking your name by force also means that it prevents everyone except for the private key owner from issuing transfers.  **You should be absolutely certain that you have the right recipient address**.\n\n### My name was transferred, but I did not do it.\n\nThis usually means someone has stolen your private key.  See the [[Private Key Lost or Stolen]] page.\n\n### Transfering\n\nNames do not need to stay bound to the same owner indefinitely.  Instead, the name owner can opt to transfer it to a new owner.  The name owner can also opt to disable the name entirely by revoking it, thereby denying all future modifications to it until it expires.\n\n### Transferring Names\n\nOnce a name has been registered, its owner can opt to transfer it to another address (i.e. another key pair).  This can be performed with the `transfer` command.\n\nThe name owner has the option of transferring the name's profile information along with the name.  If transferred, the profile content will be controllable only by recipient--the sender will be unable to update the data via Blockstore, and Blockstore will use the recipient's public key to authenticate data.  There are benefits and drawbacks to doing so depending on the circumstances, so we leave the choice to the users.  It is recommended to *not* transfer the profile information when transferring a name, since the recipient retains the option to rebuild the profile from the sender's profile at a later date.\n\nThe following command invocation will transfer a name, but not the profile data.  The third argument controls whether or not to transfer the profile.\n\n```\n$ blockstore-cli transfer <name.namespace> <recipient's Bitcoin address> False <name owner's private key>\n```\n\nThe following command invocation will transfer a name *and* the profile data.\n\n```\n$ blockstore-cli transfer <name.namespace> <recipient's Bitcoin address> True <name owner's private key>\n```\n\n#### Example\n\nThis command will transfer ownership of `swiftonsecurity.id` to the owner of the address `16firc3qZU97D1pWkyL6ZYwPX5UVnWc82V`:\n\n```\n$ blockstore-cli transfer swiftonsecurity.id 5JZAZzZo5JvCEc4x9pkNAdkLf468H4KVMMhrwcv6WKFJ9x3ZC7m 16firc3qZU97D1pWkyL6ZYwPX5UVnWc82V\n```\n\nNote that the private key `5JZAZzZo5JvCEc4x9pkNAdkLf468H4KVMMhrwcv6WKFJ9x3ZC7m` is the private key that owns the name, since its address (`199VaCaC9p95otia9e2EH7i6yZq7EWJHk2`) was the registration address in the earlier registration example (not to be confused with the preorder key pair).\n\n### Notes on Transferring Names\n\nWe anticipate that a secondary market for existing names could form around this feature.  If so, we offer the following advice to buyers:\n\n* Check the revocation status of a name before buying.  If it is revoked, it is worthless.\n* Check that the name is not going to expire anytime soon--at least not for 30 blocks.  This is because the new owner should wait for at least six confirmations to transfer, and at least another six for the renewal fee to be processed.  The time between blocks is not guaranteed to be 10 minutes.\n* Use the `get_name_cost` command to learn the actual worth of the name.\n* Make sure the name's namespace is ready for registrations--it must show up with the `lookup_namespace` command.\n","troubleshooting":"# Troubleshooting\n\nBecause Blockstore is a wide-area distributed system, there can be many sources of problems.  The common ones are documented here.  If you are encountering a problem with Blockstore that is not listed here, please join our [Slack](https://blockstack.slack.com) and let us know, or email us directly.\n\n### Network-level Errors\n\nNetwork-level errors are usually transient, and should not affect the correctness of the system beyond preventing Blockstore from learning the latest name updates.\n\n### Symptoms and Diagnosis\n\n* **Symptom:** You see error messages in the log in the form of `gaierror: <something something something>`\n  * **Diagnosis:** There is probably something wrong with your network.  Make sure you can use DNS, and make sure you have network connectivity.  Use `ping` and `dig` to see that you can resolve hostnames and reach hosts.\n* **Symptom:** You see error messages in the log in the form of `SSLError: <something something something>`\n  * **Diagnosis:** Your network is working, but Blockstore is having trouble communicating with the `bitcoind` node.  If you have `bitcoin-cli` installed, try using it to ping the node.  If you are using Onename's bitcoind fleet, the exact command is:\n\n  ```\n  $ bitcoin-cli -rpcconnect=btcd.onename.com -rpcusername=openname -rpcpassword=opennamesystem -rpcssl ping\n  ```\n\n### Database errors\n\n* **Symptom:** You see different consensus hashes and even different names than your peers.\n  * **Diagnosis:** It is possible that you are on a fork of the blockchain.  First, compare your `~/.blockstore/blockstore.snapshots` file to that of someone you trust.  Do they match up until a particular block number (beyond 373601), and then diverge?  If so, then this means one of two things:\n      * If you recently upgraded your Blockstore, you might still have an old one running.  If so, then the old one could have overwritten the `blockstore.db` and `blockstore.snapshots` files with its own copies, which may not store the same information as you expect\n      * The blockchain itself forked, and both you and your friend were on separate forks.  If this is the case, then please see the [[Blockchain Fork Recovery]] page for how to proceed.\n\n### Python-level errors\n\nThe Python runtime environment is extremely well-tested, but some of us have encountered problems with it in the past.\n\n* **Symptom:** Blockstore causes a segmentation fault, and you see some instances of `error: [Errno 32] Broken pipe` that follow.\n  * **Diagnosis:** This is probably a bug in Python's `multiprocess` module or some library on which it depends.  The best advice we can give is to make sure you are running the latest version of Python 2 branch, and your OS is up-to-date.  The only solution here is to run `blockstored stop` to clean up, and then restart blockstore.\n* **Symptom:** Blockstore throws an exception that is not described in this document\n  * **Diagnosis:** There's a bug in Blockstore.  Please post a copy of the exception [here](https://github.com/blockstack/blockstore/issues), so we can get back to you and fix it.\n\n### Rejected Transactions\n\nIf `blockstore-cli` fails to send the transaction, then no money will be spent from your wallet, you will not see a `transaction_hash` in the command output, and your profile will not be affected at all.  However, you will need to find out why:\n\n* **Are you using the right private key?**  If you send a transaction with the wrong private key, it might not have any funds associated with it.\n* **Make sure you have enough BTC in your wallet.** Updating, transferring, and revoking a name only costs as much as the dust fee and miners fees, but you will need the funds to be present and confirmed by the miners first.\n* **Make sure you have no unconfirmed transactions.** A lot of miners won't accept transactions that have unconfirmed unspent outputs. Try waiting about an hour and try again, to make sure that all your unconfirmed transactions get accepted onto the main blockchain.\n* If you are using a subsidized transaction from Blockstore, **try waiting 30 minutes and asking for a new one.**  It is possible that the Blockstore operator's node is misconfigured, or its UTXO provider did not supply the right unspent outputs for your address.  If the problem persists, you may need to contact the operator.\n* If all else fails, **try configuring Blockstore to use a different UTXO provider.** Sometimes, a UTXO provider won't see your unspent outputs for some time.\n\n### Rejected Name Operations\n\nSometimes a transaction will be successfully written to the blockchain, but Blockstore will reject it.  You can tell whether or not Blockstore rejected a transaction by searching for it in the logfile (by default, this is `~/.blockstore/blockstore.log.indexer`).  If this happens to you, it might be for the following reasons:\n\n* **Did you use the right private key?**  If you send a Blockstore operation with the wrong private key, Blockstore will not accept it.  This is because only a particular principal (or set of principals) can control a name or namespace.  Refer to the documentation on the specific command to see which private key(s) are required.\n* **Was there a delay in sending the transaction?** Some transactions (like name updates) must be sent and discovered by Blockstore within a limited amount of time.  In the unlikely case that this doesn't happen for you, you will need to re-send the transaction.  It is best to try to find out why your transaction took so long to get incorporated into the blockchain, because it may happen again (examples:  the miner you contacted was on a shorter fork; the blockchain is experiencing very high load, etc.).\n* **Is Blockstore scanning a different blockchain fork?**  Sometimes the blockchain can fork, and the Blockstore node that sent your transaction originally might be on a different fork than you.  This means that its view of the world will diverge from all the other Blockstore nodes.  If you are running a Blockstore node and this happens, please refer to the [[Blockchain Fork Recovery]] section.\n","zone-files":"# Zone Files\n\nUpdating a profile from `blockstore-cli` is a matter of giving Blockstore the JSON document that represents the new profile information.  Blockstore will put the new profile hash into the blockchain, and upload the JSON document to the DHT and all other storage providers the `blockstore-cli` tool has been configured to use.\n\nBecause this operation writes data to the blockchain, the effect of the `update` will not become visible until six subsequent blocks have been mined.  The cost of the `update` operation is simply the cost of writing the requisite outputs to the blockchain as dust, plus mining fees.\n\nGiven the nature of this operation, the write to the blockchain must precede the write to the name owner's storage providers.  In the event that the write to the blockchain fails, no data will be uploaded to any storage providers.  In the event that the write to the blockchain succeeds (i.e. the transaction gets accepted) but the upload fails, the name owner can attempt to re-upload the JSON without issuing a new transaction by submitting the transaction ID along with the `update` command.  The transaction ID is used to prove to the storage providers that the write has been paid for by the writer.\n\nThe usage of this operation is as follows:\n\n```\n$ blockstore-cli update <name.namespace> <JSON string> <privatekey> [txid]\n```\n\n#### Example\n\nSuppose the owner of the name `swiftonsecurity.id` wanted to add a minimal profile, encoded as `{\"name\":{\"formatted\":\"Swift on Security\"},\"v\":\"2\"}`.  To do so, the command would be:\n\n```\n$ blockstore-cli update swiftonsecurity.id '{\"name\":{\"formatted\":\"Swift on Security\"},\"v\":\"2\"}' 5JZAZzZo5JvCEc4x9pkNAdkLf468H4KVMMhrwcv6WKFJ9x3ZC7m\n```\n\nNote that the private key used (`5JZAZzZo5JvCEc4x9pkNAdkLf468H4KVMMhrwcv6WKFJ9x3ZC7m`) has the address `199VaCaC9p95otia9e2EH7i6yZq7EWJHk2`, which is the registration address submitted for `swiftonsecurity.id` in the earlier registration example (not to be confused with the preorder key pair).\n\nNow, suppose that the update transaction succeeded as transaction ID `cd08dd0afff9838ede0b8f4e3a9ffbe95e1c81d7da1a38582b3ce93ad10f5e5a`, but uploading `{\"name\":{\"formatted\":\"Swift on Security\"},\"v\":\"2\"}` to the DHT failed.  The owner of `swiftonsecurity.id` can re-run the upload with:\n\n```\n$ blockstore-cli update swiftonsecurity.id '{\"name\":{\"formatted\":\"Swift on Security\"},\"v\":\"2\"}' 5JZAZzZo5JvCEc4x9pkNAdkLf468H4KVMMhrwcv6WKFJ9x3ZC7m cd08dd0afff9838ede0b8f4e3a9ffbe95e1c81d7da1a38582b3ce93ad10f5e5a\n```"}