{"bootstrapping":"# Bootstrapping\n\nA full Blockstore peer not only stores each name and namespace it finds while processing the blockchain, but also the history of operations on it.  In particular, Blockstore records each name and namespace's change history, so that a client can query a name or namespace _as it was at a prior blockchain height_.  For example, suppose Alice preordered `alice.id` at block 400000, registered it at block 400010, updated it twice in block 400020, and transferred it to Bob at block 400030.  Then, Charlie can query a Blockstore node for the state of the name `alice.id` as it was at block 400011, and see that it was registered to Alice.  At block 400009, he would see that it was still preordered.  He can query it at block 400025 and see that Alice had updated the name (he would see the effect of the second update).  He can also query the name at block 400031 and see that it was transferred to his public key.\n\nAs part of storing each name and namespace's history, Blockstore can determine at which block heights a record was changed.  For example, Charlie can query the change history for `alice.id`, and get back the list `[400000, 400010, 400020, 400030]`.\n\nBecause a name or namespace can be affected by multiple transactions within a single block, Blockstore additionally keeps track of the transaction-level ordering of a name's history.  For example, Charlie can query the number of times the record for `alice.id` changed in block 400020, and would be informed that it changed twice (because Alice sent two update-transactions).  If he queried the state of `alice.id` at block 400020, Blockstore would give him two versions of `alice.id`:  `alice.id` as it was when it was registered but not updated, and `alice.id` as it was when it was updated for the first time.\n\nThese three features--querying a record's past states, querying the block heights where a record changed, and querying how often it changed in a block--allow Blockstore to use a trusted consensus hash to verify the authenticity of an untrusted Blockstore peer's database.  Once it has done so, it can use the database instead of having to re-create it by downloading the blockchain.\n\nTo see how it works, consider that each record has the following information:\n\n* the index into the block of the transaction that changed it ('`txindex`')\n* the list of block heights where it changed ('`history`')\n* for each block height in '`history`', a list of '`txindex`' values where the name changed.\n* for each '`txindex`' value at a given block height, the list of fields that were changed by the transaction ('`changeset`') \n* a record-specific method ('`rollback`') that takes a record's history, changeset, historical block height, and transaction index as arguments and returns the record as it was at that particular block height and transaction.  This is simply a matter of iteratively copying over the fields from '`changeset`' into the current state in order from present back to the past, historical timestamp (similar to how a version control system would roll a source file back to a particular commit).\n\nTo verify the authenticity of an untrusted database, the Blockstore peer executes the following algorithm (Figure 2).\n\n```\ninput:\n   trusted_consensus_hash:  the trusted consensus hash\n   h:  the height of the block with the trusted consensus hash\n   h0: the initial block height\n   db: the untrusted database, as a list of records\n\noutput:\n   if successful, True\n   if unsuccessful, False\n\nsubroutines:\n   CONSENSUS_HASH( recs, consensus_hash_list ):  calculate the canonical serializations of each record in recs, and then calculate the cryptographic hash over them as well as the given consensus hash list\n\nlet consensus_hashes = []\nfor each block i from h0 to h\n\n   let recs_i = [rec where i in rec.history for rec in db]\n   let block_i_recs = []\n   let block_i_consensus_hashes = []\n\n   sort recs_i on 'txindex'\n   for rec in recs_i\n      let txindexes = rec.history[i]\n      sort txindexes\n\n      for txi in txindexes:\n         let historic_rec = rec.rollback(rec.history, rec.changeset, i, txi)\n         block_i_recs = block_i_recs ++ [historic_rec]\n   \n   let j = i - 1\n   while j >= h0\n      block_i_consensus_hashes ++ [consensus_hashes[j]]\n      j = j / 2\n   \n   let ch = CONSENSUS_HASH( block_i_recs, block_i_consensus_hashes )\n   consensus_hashes = consensus_hashes ++ [ch]\n\nif consensus_hashes[h] == trusted_consensus_hash\n   print \"db is consistent with the trusted consensus hash\"\n   return True\n\nelse\n   print \"db is not consistent with the trusted consensus hash\"\n   return False \n```\n\n_Figure 2: The fast bootstrapping algorithm's pseudocode.  Blockstore executes this to verify the authenticity of another Blockstore peer's database.  If the authenticity can be verified, then the peer can bootstrap itself from the database, without having to download the blockchain and regenerate its own database from scratch_\n\nIn effect, the Blockstore peer translates the database back into the sequence of transactions the untrusted peer processed, and replays them to recalculate the final consensus hash.  If it matches the trusted consensus hash, then the database is trustworthy.","consensus-rules":"# Consensus Rules\n\n![Consensus hash construction overview](/images/docs/consensus-hash.png)\n\n_Figure 1: Overview of how a consensus hash is constructed from a block's transactions_\n\nA Blockstore peer broadcasts name operations by writing them as transactions on an underlying blockchain.  Peer Blockstore nodes discover them by reading the blockchain and replaying the operations sequentially.  In doing so, the blockchain serves as an append-only log of Blockstore name operations, which when replayed in sequence allow a Blockstore peer to determine the history of operations on each name and namespace.\n\nBlockstore generates a consensus hash in a deterministic way by hashing a block's sequence of name operations, as well as a logarithmic number of prior consensus hashes (Figure 1).  At block height `h`, the consensus hash is calculated by first hashing the canonical forms of each name operation in transaction order, and then hashing the prior consensus hashes for all blocks at heights `{h | h - 2^i && i > 0 && h - 2^i >= h0}` (where `h0` is the block height of the first-ever name operation).  Consensus hashes are processed in a deterministic order, such as in increasing order on `i`.  This way, two Blockstore peers at block `h` will calculate the same consensus hash (with very high probability) if and only if they observed the same sequence of name operations and the same sequence of prior consensus hashes.","data-storage":"# Data Storage\n\nStoring large amounts of data in the blockchain can lead to blockchain bloat, so we decided to use external datastores, e.g., a DHT, for data storage while storing only hashes of the data in the blockchain, yielding virtually unlimited storage. Currently, the default (external) datastore is a kademlia-based DHT which is seamlessly integrated with blockstored.\n\nTo associate data with the name, one issues an \"update\" operation by including a hash of the data and storing the data itself in the DHT.\n\n### Data storage comparison\n\n|Method|Bytes|\n|---|---|\n|nulldata in OP_RETURN output|40|\n|nulldata in multi-sig output|66|\n|namecoin operation|520|\n|hash in nulldata, full data in DHT|unlimited|\n\n### Control Plane vs. Data Plane \n\nWe believe that the design principle of separating the \"control plane\" from the \"data plane\" (recently, popularized by [OpenFlow](https://www.opennetworking.org/)) applies to blockchain-based datastores. We separate the problem of a) who is the owner of a name and can issue updates to a name-value pair from b) what is most efficient (speed/cost/reliability) way of delivering data to the end-user. For (a) it makes sense to use the blockchain and for (b) it doesn't.\n\nThe control plane, should include registration and update of name-value pairs. Given the secure nature of these operations, performing them on the blockchain makes sense. We need to establish, in a decentralized manner, who registered which name before others and who is the owner of which name and issue updates. \n\nThe data plane, is primarily used to deliver the actual data. Hash(value) is in the blockchain and the actual 'value' is stored externally. Since hash(value) is in the blockchain, the only type of attack possible on external storage is data unavailability attack. Anyone can independently confirm that they received the correct value by checking the hash(value) in the blockchain. We believe that standard data delivery optimizations like CDNs, geo-mirrors, keeping copies of data in large-memory servers (e.g., memcached) etc applies to our design.   \n\n### Multiple External Stores \n\nCurrently, we only have one external datastore for storing values -- the kademlia-based DHT. However, there can be many external datastores e.g., [IPFS](https://github.com/ipfs/ipfs), [Syndicate](https://github.com/jcnelson/syndicate) etc. In fact, any person or company can decide to run a mirror and add the mirror to a \"discovery service\". How exactly to build such a discovery service is currently an [open question](https://github.com/openname/blockstore/issues/84). Orgs/people can also choose to mirror/index only a particular namespace and they don't have to mirror all data on Blockstore. This helps with scalability by adding one-layer of hierarchy. Let's say there are *m* namespaces with *n* name-value pairs in each namespace. Instead of indexing O(m x n), you can index O(n) information and *n* for your namespace could be significantly small.\n\n### Storage Layer\n\nThe top-most layer is the storage layer, which hosts the actual data values of name/value pairs. All stored data values are signed by the public-key of the respective owner of a name. By storing data values outside of the blockchain, Blockstore allows values of arbitrary size, and allows for a variety of storage backends. The control plane does not need to trust the storage layer, because it can verify the integrity of the data value in the control plane. There are two modes of using the storage layer and they differ in how the integrity of data values is verified.\n\n### Mutable Storage\n\nMutable storage is the default mode of operation for the storage layer. Bindings between name and hash(route) are kept in the control plane and the routing layer is used to discover data values. Integrity of data values is verified by checking the signatures of signed values. It allows for faster writes since data updates do not involve any transactions on the blockchain, which has slow writes. Updates to name/value pairs also don’t take any bandwidth on the blockchain (only name registrations do).\n\n### Immutable Storage\n\nImmutable Storage: by-passes the routing layer and stores bindings between name and hash(value) in the control plane, instead of bindings between name and hash(route). Integrity of data value is checked by hashing the data and checking against the hash(data) from the control plane. This mode is suitable for data values that don’t change often and where it is important to verify that you are viewing the latest version of the data value. For immutable storage, updates to data values require a new transaction on the underlying blockchain, making data updates much slower than mutable storage. Blockstore supports both storage modes simultaneously.\n","faq":"# FAQ\n\n### Why did you choose to build on top of Bitcoin?\n\nBitcoin is the blockchain with the most users, the largest market cap, the most amount of software available for it, and the highest amount of security (in terms of the cost of attack). It only makes sense to gravitate to the top blockchain among cryptocurrencies.\n\n### Are you open to building on other blockchains?\n\nYes! While we decided to follow our instincts and build our experimental KV store on the Bitcoin blockchain, we are and have been considering other options like alt-coins, sidechains, and even a Namecoin upgrade. If you have a suggestion and some detailed information about why it makes more sense, please open an issue and we'll discuss.\n\n### How is the Blockstore different from Namecoin?\n\nThis is different from Namecoin in a few fundamental ways:\n\n1. It uses the Bitcoin blockchain, which is the top blockchain. See above.\n2. Rather than store data directly in the Blockchain, this stores the data outside of the blockchain in a DHT. This reduces blockchain bloat and allows for more data to be conveniently stored.\n3. Each namespace has a different pricing scheme for names. That means you can use a namespace with expensive names in order to avoid squatting (ideal for domains), or you can use a namespace with names that cost almost nothing, in order to save money (ideal for non-fungible tokens like trading cards), or you can go for something in the middle (ideal for usernames).\n4. Fees paid to register names go to miners instead of being burned or essentially wasted. This incentivizes mining and increases the overall security of the network.\n\n### Is there a mechanism to store encrypted data?\n\nThere isn't any support for this in this repo. However, to store encrypted data, simply encrypt your file before submitting the data to the blockchain.\n\n### Can't someone just store huge files in the DHT?\n\nNo, we currently cap the size to 8kb. The DHT is not meant for storage of large files (e.g. pictures, videos, etc.) and is only intended for relatively small or moderately sized plaintext files.  Instead, we provide a [storage API](https://github.com/blockstack/blockstore/wiki/Data-Storage) in Blockstore to give users the ability to get, put, and delete large data from storage providers of their choosing.\n\n### Aren't DHTs vulnerable to sybil attacks?\n\nYes. Unfortunately like Bitcoin and other systems, sybil attacks are possible. There is no theoretical solution to sybil attacks, but we take certain practical steps to minimize the effects and risks of this. Also, keep in mind that the only type of attack possible on the DHT is the \"data unavailablity\" attack. Anyone can independently verify that they received the correct data by checking the hash of the data in the blockchain. \n\n### Can nodes just pop in and out and confuse the network?\n\nYes, with nodes entering and exiting a DHT (a process known as churn), the routing tables of the DHT can get affected. The DHT network will recover from this over time, so unless someone is actively attacking the DHT 24/7, occasional churn is going to be largely unnoticeable.\n\n### Is there any incentive to run a node?\n\nNot currently, no.  Only that anyone who turns on the DHT node feature in blockstored is also by default running a full DHT node. If you have any ideas about explicit incentives for running DHT nodes, feel free to reach out!\n\n### Is there a layer on top of the DHT that can make it simpler to grab the data?\n\nAnyone can create a cache of all the DHT data by using the index of the data from the blockchain. We plan on creating such caches (e.g., in memcached servers) and providing easy access to the data through an API. Remember that anyone can verify that the data they received is correct by checking the hash of the data in the blockchain (so you're not trusting the DHT or the cache server).\n\n### Can I build and host my own index/cache of the data in the DHT?\n\nAbsolutely! Anyone can. See above. \n\n### Is OP_RETURN the only way to embed the operation data in the blockchain?\n\nCurrently, yes. However, we recognize the potential to use multi-sig transaction outputs and standard pay-to-pubkey-hash transaction outputs. If you think it's a good idea to add these options, open an issue and we'll discuss it.\n\n### Why do I have to preorder a name before registering it?\n\nIf we didn't require a step before registration, someone could just see that you're broadcasting the registration of a particular name and race you to have their registration included in the next block. By separating the registration into two steps, we're able to support the pre-registration of an undisclosed name followed by the public confirmation of the registration of that name.\n\n### Isn't it essentially free for miners to register names?\n\nNo.  All registration fees, renewal fees, and namespace creation fees are sent to the burn address 1111111111111111111114oLvT2.\n\n### Is there support for names that don't ever expire?\n\nYes. Each namespace has it's own settings, so if you'd like to register names that don't expire, simply use a namespace that has a flag set for non-expiration.\n\n### If my I update my profile daily, my transaction costs will be high. Can I avoid this?\n\nThere are a few ways to avoid this. The first method is to put the somewhat consistent profile data in the main blob, then include a pointer to a JSON file that has the extended data. Profile explorers will read the data in the file as an extension of the main blob, so updating the file will let you update the profile data without issuing a new transaction and updating the hash associated with the name. You can learn more in the openname specifications repo.\n\n### Can a name be owned by a multi-sig address?\n\nAbsolutely. In this system, names are owned by scriptPubKeys, so all scriptPubKey types that Bitcoin supports are supported here.","fork-detection":"# Fork Detection\n\nDue to their decentralized nature, proof-of-work blockchains like Bitcoin's cannot not guarantee write stability.  At any given point in time, there can be multiple blockchain _forks_--different blockchains worked on by disjoint sets of peers that diverge at a particular block.  This can happen if there is a network partition between two or more sets of peers, or if two sets of peers discover a different block for the same height at about the same time (Figure 5).\n\nThe way blockchain peers resolve diverging forks is to always attempt to work on the blockchain with the highest proof-of-work (i.e. the fork that cost the most energy to produce), and to discard all other forks.  This means that if a blockchain peer submits a transaction, it is possible for the peer to witness the transaction get incorporated into a block, but then later discard the block if the block was later discovered to be on a fork.\n\n![Blockchain fork event timeline](/images/docs/blockchain-fork.png)\n\n_Figure 5:  Timeline of events when the blockchain encounters a fork.  The transaction tx2 gets incorporated into a block on a fork that is later discarded.  As a result, only tx1 will appear on the blockchain with the most proof-of-work._\n\nThe consequence for Blockstore is that name operations can get lost if they are incorporated onto a minority fork.  This will lead to a divergence in the Blockstore peers' consensus hashes, since some peers will process name operations on a minority fork while others will not.  This is particularly devistating to name registrars that broadcast many name operations in a small amount of time, because they stand to lose a large number of transactions.  The challenge is to provide a way to quickly and automatically detect and resolve consensus hash divergences due to blockchain forks, in order to minimize the amount of time required to recover and minimize the number of lost transactions.\n\nFortunately, if the current block height is `h`, then the probability that the block at height `h - k` is on a fork decreases exponentially as a function of `k`.  As a result, Blockstore can avoid most forks simply by processing blocks only if they are at least `k` blocks lower than the highest block in the blockchain.  However, this does not eliminate the threat of forks.\n\n![Blockchain fork detection and recovery](/images/docs/fork-recovery.png)\n\n_Figure 6:  Schematic of Blockstore peer and backup peer deployments.  When a Blockstore peer detects disagreement in its consensus hash (1), it queries back-up peers until it finds an agreeing consensus hash (2).  From there, it fetches a copy of the back-up peer's database (3) and catches itself up to block `h - k`.  Blockstore operators that process many name operations back up successfully-sent operations to an indepedent, durable database (in green), so they can be replayed if all Blockstore nodes diverge._\n\nThe solution to detecting forks is to configure a set of mutually-trusting Blockstore peers to fetch the blockchain from different sources, and configure the peers to check every time a new block is discovered to see if they all agree on the same consensus hash at height `h - k` (Figure 6).  If they do not, then a fork at least `k` blocks long has occurred, and each peer needs to check with the backups to see if it diverged.  If it diverged, then it needs to roll back its database to the block height where it diverged, and re-download the blockchain to re-converge on the correct consensus hash.\n\nTo faciliate recover, a Blockstore peer operator runs an additional set of private, back-up Blockstore peers that process blocks up to heights `h - k - 2^i`, for all positive integers `i` such that `h - k - 2^i >= h0`.  These peers are not meant to be publicly reachable, but instead curate prior states of all name and namespace records, and serve as recovery checkpoints for the public set of peers processing blocks at height `h - k`.  If a peer processing at height `h - k` detects that it could be on a fork, it works backwards from the consensus hash at found at height `h - k` to find a consensus hash at height `h - k - 2^i` where it still agrees with a back-up peer.  In particular, it checks each consensus hash down from `h - k` in a linear fashion, and selects the peer with the largest `h - k - 2^i` that has a consensus hash that agrees.  Once found, the peer fetches a copy of the back-up peer's database, authenticates it (if the back-up peer is not trusted), and then re-builds the database up to height `h - k` by downloading the missing blocks from the blockchain.\n\nThe distribution of block heights the back-up peers follow was chosen to balance the number of blocks a peer will need to re-download on recovery against the likelihood of having to recover from a fork of a particular length.  The number of blocks a peer must re-download on recovery from a fork at height `h - d` is minimized when there is a back-up peer with a database at `h - d`.  However, it is inefficient to run `h0 - h` back-up peers, and most forks are expected to resolve in less than `k` blocks (those that don't are much more likely to resolve at depth `d` than at `d+1`).  Selecting a power-of-2 distribution of back-up peer height intervals ensures that a recovering peer will not download more than twice the number of blocks than the minimum number required, while also ensuring that the number of necessary back-up peers grows logarithmically with the blockchain height.  In addition, the interval distribution places most back-up peers close to `h - k`, which we expect to cover nearly all of the fork recovery scenarios for forks greater than `k` blocks.\n\nIt must be noted that this fork detection and recovery protocol only guarantees that the set of Blockstore peers are on the same fork; it does not guarantee that they are always on the majority blockchain fork, since it is possible for every Blockstore peer and corresponding blockchain peer to be on a minority fork.  The distribution of Blockstore peers and the blockchain peers they communicate with must be kept diverse, in order to minimize the chance of this happenning.  To prepare for this scenario, the Blockstore peer operator (e.g. a registrar) should replicate each processed name operation, independent of Blockstore peers, so they can be re-submitted once the fork resolves and the Blockstore peers are recovered.","index":"# Blockstack\n\nBlockstack is decentralized DNS.\n\nBlockstack is for truly secure naming.\n\nBlockstack is for blockchain applications.\n\nBlockstack is for never needing to trust certificate authorities again.\n\nBlockstack is for a better, more secure way to build applications.\n\n### Installation\n\n```\n$ apt-get install blockstack\n```\n\n### Lookups\n\n```\n$ blockstack lookup <name>\n```\n\n### Registrations\n\n```\n$ blockstack register <name>\n```\n\n### Zonefile Updates\n\n```\n$ blockstack update <zonefile_data>\n```\n","installation":"# Installation\n\nThis page is meant to walk you through installing and starting up Blockstore for the first time.\n\n### Requirements\n\n- [x] Acccess to a bitcoin node with a full transaction index (i.e. txindex is\nenabled). You need to be able to connect to a specific bitcoin node that stores\neach transaction. Note: This is ​*not*​ the default behavior, the `txindex` option\nhas to be explicitly enabled in the node.  For example, `btcd.onename.com` has\nthis feature enabled.\n- [x] [Python 2.6 or higher](https://www.python.org/). (Python 3.x not supported)\n- [x] Python 2.x development headers (in most Linux distributions, this is usually the `python-dev` or `python-devel` package).\n- [x] [The Python distutils package](https://docs.python.org/2/distutils/) (Verify\nas it is not always installed with Python)\n- [x] [Python pip](https://pypi.python.org/pypi/pip)\n\n### Installing with pip\n\nTo install Blockstore from the (Python Package Index)[https://pypi.python.org/pypi], you can use the following command:\n\n```\n$ pip install blockstore\n```\n\nThis will install Blockstore, and all of its dependencies.\n\n### Installing from Source\n\nWe use distutils to package Blockstore, and provide a setup.py script to pull in additional dependencies.  The package is built with:\n\n```\n$ python setup.py build\n```\n\nTo install blockstored and all of its dependent packages, run:\n\n```\n$ sudo python setup.py install\n```\n\n### Running Blockstore for the First Time\n\nWhen you run Blockstore for the first time, you will be prompted for some basic configuration information.  In particular, Blockstore will need to know how to connect to your bitcoin node, and how to connect to a Bitcoin API provider.  By default, Blockstore will connect to the Bitcoin node fleet that Onename maintains.\n\nConnecting to a bitcoin node is just a matter of supplying Blockstore with the server, port, and login information.  Blockstore will pull transactions and data from it to reconstruct the name database locally.  In particular, Blockstore prompts for:\n\n* `user`: the bitcoin's RPC username (akin to `-rpcuser` in bitcoin-cli).  It defaults to `openname`.\n* `passwd`: the bitcoin's RPC password (akin to `-rpcpassword` in bitcoin-cli).  It defaults to `opennamesystem`.\n* `server`: the name or IP address of the bitcoin node (akin to `-rpcconnect` in bitcoin-cli).  It defaults to `btcd.onename.com`.\n* `port`: the RPC port number of the bitcoin node (akin to `-rpcport` in bitcoin-cli).  It defaults to `8332`.\n* `use_https`: whether or not to use SSL.  If you are unsure, type `True`.  It defaults to `True`.\n\nBlockstore needs to access [unspent outputs](https://bitcoin.org/en/glossary/unspent-transaction-output) (UTXOs) to create transactions. Bitcoind does not track UTXOs for all Bitcoin addresses, therefore blockstore needs access to a full UTXO index. Blockstore currently has the option to specify an API provider for accessing UTXOs and users don't need to deploy a UTXO index/database themselves. The API provider gets used to find unspent outputs and also for broadcasting transactions.  Blockstore comes with API support for:\n\n* [Blockcypher](http://www.blockcypher.com/)\n* [chain.com](http://chain.com)\n* [blockchain.info](https://blockchain.info)\n* A bitcoin node configured to track UTXOs\n\nYou will be prompted to select one of the four.  In the case of chain.com, Blockcypher, and blockchain.info, you will need to obtain an API token.  The details of how to go about doing so can be found at each of the websites above.  Blockchain.info and Blockcypher currently offer free API tokens.\n\nOnce you have chosen your API provider and have an API token, Blockstore will prompt you for them.  After you have entered all of the requisite information, Blockstore will save its configuration to `~/.blockstore/blockstore.ini` for future use.  \n\n#### Example\n\nBelow is an example trace of running `blockstored` for the first time.  The user selected the default options for connecting to the Bitcoin network, and selected Chain.com as the API provider.  The API token is redacted.\n\n```\n$ ./blockstored start\n--------------------------------------------------------\nBlockstore does not have enough information to connect\nto bitcoind.  Please supply the following parameters, or\npress [ENTER] to select the default value.\n--------------------------------------------------------\npasswd (default: 'opennamesystem'): \nport (default: '8332'): \nuser (default: 'openname'): \nuse_https (default: 'True'): \nserver (default: 'btcd.onename.com'): \n--------------------------------------------------------\nNOTE: Blockstore currently requires an external API\nfor querying unspent transaction outputs.  The set of\nsupported providers are:\nchain_com       \nblockcypher     \nblockchain_info \nbitcoind_utxo\nPlease get the requisite API tokens and enter them here.\n--------------------------------------------------------\nutxo_provider: chain_com\n-----------------------------------------------\nPlease enter your chain.com API key and secret.\n-----------------------------------------------\napi_key_id: *********\napi_key_secret: ********\n```\n\n### Administrating Blockstore\n\nOnce you have configured blockstore, you will subsequently be able to start it with:\n\n```\n$ blockstored start \n```\n\nTo stop blockstore, simply run:\n\n```\n$ blockstored stop\n```\n\nBy default, blockstore will synchronize its database with the blockchain, and then become a daemon and serve RPC requests in the background.  If you want it to run in the foreground, simply pass `--foreground` with the `start` option (example: `blockstored start --foreground`).  By default, blockstore will log RPC requests to `~/.blockstore/blockstore.log.access` and blockchain indexing debug messages to `~/.blockstore/blockstore.log.indexer`.","light-nodes":"# Light Nodes\n\nThe set of back-links from a given block `h` to all blocks `h - 2^i` constitute a _Merkle skip-list_ (Figure 2).  Given the consensus hash at height `h`, a client can use an untrusted Blockstore peer to determine the name operations at any prior block using a logarithmic number of queries relative to blocks, and downloading a logarithmic number of bytes relative to the blockchain's size.  The process of verifying the authenticity of a prior name operation with a later known-good consensus hash is caled _Simplified Name Verification_ (SNV).\n\n![SNV protocol overview](/images/docs/snv-overview.png)\n\n_Figure 3: Overview of Simplified Name Verification (SNV) protocol.  Each row represents the blockchain, in decreasing block height order from left to right (h > h0).  The user wishes to verify the authenticity of a name operation in the block marked with a `?`.  In each step, the user trusts the consensus hash for the white outlined block, and uses it to verify the authenticity of that block's name operations, as well as the set of prior consensus hashes (belonging to yellow blocks indicated by the arrows).  By iteratively fetching name operations and consensus hashes for prior blocks, the user will eventually prove the authenticity of all name operations in the `?` block._\n\nTo see how this works, suppose that a user trusts the consensus hash at height `h`, but needs to verify a name operation in block `h - 11`.  Suppose that the blockchain currently has 17 blocks beyond height `h0` (Figure 2).  To do so, the user queries any Blockstore node to obtain all of the name operations processed at height `h`, and the consensus hashes for blocks `h - 1`, `h - 2`, `h - 4`, `h - 8`, and `h - 16`.  Once obtained, the user serializes the name operations and prior consensus hashes to re-calculate the consensus hash at `h`.  If the trusted consensus hash matches, then the user knows that both the name operations the prior consensus hashes are authentic.  The user then iteratively downloads name operations and consensus hashes in this way, until block `h - 11` is reached.  Then, the user will have obtained and verified the authenticity of all name operations in that block, including the desired name operation.\n\nA full trace of the algorithm's execution follows:\n\n* Let `CH(h)` be the consensus hash at block height `h`.\n* Let `HISTORIC_RECORDS(h)` be a subroutine that queries all records affected by transactions in the block at height `h`.  The returned records are in the historic state they were in at height `h` (see the \"Fast Bootstrapping\" section for details).\n\nFigure 3, step (1):\n\n1.  Fetch `HISTORIC_RECORDS(h)`, `CH(h-1)`, `CH(h-2)`, `CH(h-4)`, `CH(h-8)`, and `CH(h-16)`.\n2.  Serialize and hash `HISTORIC_RECORDS(h)`, `CH(h-1)`, `CH(h-2)`, `CH(h-4)`, `CH(h-8)`, and `CH(h-16)` and verify equal to `CH(h)`.  If not, abort.\n3.  `CH(h-8)` is now trusted, and is the closest consensus hash to block `h - 11`.\n\nFigure 3, step (2):\n\n4.  Fetch `HISTORIC_RECORDS(h-8)`, `CH((h-8)-1)`, `CH((h-8)-2)`, `CH((h-8)-4)`, and `CH((h-8)-8)`.\n5.  Serialize and hash `HISTORIC_RECORDS(h-8)`, `CH((h-8)-1)`, `CH((h-8)-2)`, `CH((h-8)-4)`, and `CH((h-8)-8)` and verify equal to `CH(h-8)`.  If not, abort.\n6.  `CH(h-8-2)` is now trusted, and is the closest consensus hash to block `h - 11`.\n\nFigure 3, step (3):\n\n7.  Fetch `HISTORIC_RECORDS(h-8-2)`, `CH((h-8-2)-1)`, `CH((h-8-2)-2)`, and `CH((h-8-2)-4)`.\n8.  Serialize and hash `HISTORIC_RECORDS((h-8)-2)`, `CH((h-8-2)-1)`, `CH((h-8-2)-2)`, and `CH((h-8-2)-4)` and verify equal to `CH(h-8-2)`.  If not, abort.\nM9.  `CH(h-8-2-1)` is now trusted, and is the consensus hash of the block with the name operations to verify.\n\nFigure 3, step (4):\n\n10.  Fetch `HISTORIC_RECORDS(h-8-2-1)`, `CH((h-8-2-1)-1)`, `CH((h-8-2-1)-2)`, and `CH((h-8-2-1)-4)`\n11.  Serialize and hash `HISTORIC_RECORDS(h-8-2-1)`, `CH((h-8-2-1)-1)`, `CH((h-8-2-1)-2)`, and `CH((h-8-2-1)-4)` and verify equal to `CH(h-8-2-1)`.  If not, abort.\n12.  `HISTORIC_RECORDS(h-8-2-1)` is now trusted.  Return the queried record as it was at block `h - 11`.\n\nExtrapolating, the general SNV algorithm works as follows (Figure 4).\n\n```\ninput:\n   trusted_consensus_hash:  the trusted consensus hash \n   h:  the height of the block with the trusted consensus hash \n   rec_id:  the name or namespace ID to query\n   h_rec:  the height of the record to query (must be less than h)\n   h0:  the height of the block with the first-ever Blockstore operation\n\noutput:\n   if successful, the queried record as it was at height h_rec\n   if unsuccessful, False\n\nsubroutines:\n   HISTORIC_RECORDS(h):  query to Blockstore that finds all records affected by transactions at height h, restores them to their state at height h, and returns them\n   CH(h):  query to Blockstore that returns the consensus hash at height h\n   CONSENSUS_HASH( recs, consensus_hash_list ):  calculates the consensus hash from a list of records and prior consensus hashes\n\nlet current_h = h\ntrusted_consensus_hash_table = {\n   h: trusted_consensus_hash\n}\n\nwhile current_h >= h_rec\n   let historic_recs = HISTORIC_RECORDS(current_h)\n   let current_consensus_hashes = []\n   let i = 1\n\n   while current_h - 2^i >= h0\n      let ch = CH(current_h - 2^i)\n      current_consensus_hashes = current_consensus_hashes ++ [ch]\n      i = i + 1\n\n   let ch_at_h = CONSENSUS_HASH(historic_recs, current_consensus_hashes)\n   if ch_at_h != trusted_consensus_hash_table[current_h]\n      print \"Consensus hash mismatch at height \", ch_at_h\n      return False\n\n   if current_h == h_rec\n      break\n \n   else\n      let current_h = minimum([k for k in trusted_consensus_hash_table.keys where k >= h_rec])\n   \nprint \"Consensus hash matches\"\nfind rec in historic_recs where rec.rec_id == rec_id\nreturn rec\n```\n\n_Figure 4: The SNV algorithm pseudocode.  A Blockstore client executes this algorithm to use a known-good consensus hash to determine the prior state of a given record.  The client does not need to trust the Blockstore peer._","name-lookups":"# Name Lookups\n\nThis page describes how to look up information on a name.  You will need to have installed [blockstore-client](https://github.com/blockstack/blockstore-client), and have access to a full Blockstore node.\n\n### Getting a Name's Data\n\nUsers use Blockstore to securely associate data with their names.  The data itself is stored externally in a DHT, but the hash and some metadata is embedded in the underlying blockchain.  To fetch the *data*, the command format is as follows:\n\n```\n$ blockstore-cli lookup <name>\n```\n\nUpon successful execution, the command will print out a JSON object with the following fields:\n\n* `address`: the base58-encoded hash of the name owner's public key (i.e. their Bitcoin address).\n* `creation`: this is a JSON object with the following fields:\n   * `consensus_hash`: This is the consensus hash for this name's import or preorder.  If the name was imported, the consensus hash comes from the namespace preorder transaction in the blockchain.  If the name was preordered, the consensus hash comes from the preorder transaction in the blockchain.\n   * `consensus_block_id`: This is the block number for the above consensus hash.\n   * `type`:  This is either \"NAME_PREORDER\" if the name was preordered, or \"NAME_IMPORT\" if the name was imported.  It indicates how to interpret the above consensus hash and block number.\n* `serial_number`: this is the globally-unique identifier for the name.\n* `zone_file`: this is the data associated with the name, fetched from the DHT.  The contents of this field are arbitrary, but it is usually a JSON document.\n\nIf the name was since updated, it will also have a `modified` field in addition to the `creation` field.  The `modified` field contains the exact same structure, but with values reflecting the most recent update or transfer.\n\nOn error, the command will print out a JSON object with an `error` field.\n\n#### Example\n\nIn this example, we look up the data associated with the name `judecn.id`.  The associated data just happens to be a JSON document in this case, but the data can be anything at all in practice.\n\n```\n$ blockstore-cli lookup judecn.id         \n{\n    \"address\": \"16EMaNw3pkn3v6f2BgnSSs53zAKH4Q8YJg\",\n    \"creation\": {\n        \"consensus_block_id\": 373600,\n        \"consensus_hash\": \"17ac43c1d8549c3181b200f1bf97eb7d\",\n        \"type\": \"NAME_IMPORT\"\n    },\n    \"serial_number\": \"373622-63\",\n    \"zone_file\": {\n        \"avatar\": {\n            \"url\": \"https://s3.amazonaws.com/kd4/judecn\"\n        },\n        \"bio\": \"PhD student\",\n        \"bitcoin\": {\n            \"address\": \"17zf596xPvV8Z8ThbWHZHYQZEURSwebsKE\"\n        },\n        \"cover\": {\n            \"url\": \"https://s3.amazonaws.com/97p/gQZ.jpg\"\n        },\n        \"facebook\": {\n            \"proof\": {\n                \"url\": \"https://facebook.com/sunspider/posts/674912239245011\"\n            },\n            \"username\": \"sunspider\"\n        },\n        \"github\": {\n            \"proof\": {\n                \"url\": \"https://gist.github.com/jcnelson/70c02f80f8d4b0b8fc15\"\n            },\n            \"username\": \"jcnelson\"\n        },\n        \"location\": {\n            \"formatted\": \"Princeton University\"\n        },\n        \"name\": {\n            \"formatted\": \"Jude Nelson\"\n        },\n        \"twitter\": {\n            \"proof\": {\n                \"url\": \"https://twitter.com/judecnelson/status/507374756291555328\"\n            },\n            \"username\": \"judecnelson\"\n        },\n        \"v\": \"0.2\",\n        \"website\": \"http://www.cs.princeton.edu/~jcnelson\"\n    }\n}\n```\n\nHere is an example of a lookup on a user that does not exist:\n\n```\n$ blockstore-cli lookup nonexistent.id\n{\n    \"error\": \"Not found.\"\n}\n```\n\n### Getting a Name's Metadata\n\nThe blockchain itself stores some metadata for each name, which Blockstore tracks separately.  The metadata includes information such as a name's update history, the locations in the blockchain at which the name was altered, and so on.  The command format is as follows:\n\n```\n$ blockstore-cli get_name_blockchain_record <name>\n```\n\nOn success, the command prints out a JSON object that contains all the information Blockstore learned about this name from the underlying blockchain.  See the \"Reading and Writing Name Profiles\" section in the [Usage](https://github.com/blockstack/blockstore/wiki/Usage) document for an overview of what each of the fields mean.\n\nIf this command fails, it prints out a JSON object with an `error` key, as well as an associated error message.\n\n#### Example\n\nIn this example, we look up the blockchain metadata for the name `judecn.id`\n\n```\n$ blockstore-cli get_name_blockchain_record judecn.id\n{\n    \"address\": \"16EMaNw3pkn3v6f2BgnSSs53zAKH4Q8YJg\",\n    \"block_number\": 373622,\n    \"first_registered\": 373622,\n    \"history\": {\n        \"373622\": [\n            {\n                \"address\": \"16firc3qZU97D1pWkyL6ZYwPX5UVnWc82V\",\n                \"fee\": 38500,\n                \"history_snapshot\": true,\n                \"importer\": \"76a9143e2b5fdd12db7580fb4d3434b31d4fe9124bd9f088ac\",\n                \"importer_address\": \"16firc3qZU97D1pWkyL6ZYwPX5UVnWc82V\",\n                \"name\": \"judecn.id\",\n                \"opcode\": \"NAME_IMPORT\",\n                \"recipient\": \"76a914caee018147f2d5ff32ca3b2ef35c17755bce440e88ac\",\n                \"recipient_address\": \"1KVzcgurJmTr4Cr44h6raEVtoGhm7ZZxzm\",\n                \"sender\": \"76a9143e2b5fdd12db7580fb4d3434b31d4fe9124bd9f088ac\",\n                \"sender_pubkey\": \"0411d88aa37a0eea476a5b63ca4b1cd392ded830865824c27dacef6bde9f9bc53fa13a0926533ef4d20397207e212c2086cbe13db5470fd29616abd35326d33090\",\n                \"txid\": \"c698ac4b4a61c90b2c93dababde867dea359f971e2efcf415c37c9a4d9c4f312\",\n                \"value_hash\": \"dbbdedc2b81d875403cc76486625a19f1e3b3c6f\",\n                \"vtxindex\": 63\n            }\n        ],\n        \"374075\": [\n            {\n                \"address\": \"1KVzcgurJmTr4Cr44h6raEVtoGhm7ZZxzm\",\n                \"importer\": \"76a9143e2b5fdd12db7580fb4d3434b31d4fe9124bd9f088ac\",\n                \"importer_address\": \"16firc3qZU97D1pWkyL6ZYwPX5UVnWc82V\",\n                \"sender\": \"76a914caee018147f2d5ff32ca3b2ef35c17755bce440e88ac\",\n                \"sender_pubkey\": \"0411d88aa37a0eea476a5b63ca4b1cd392ded830865824c27dacef6bde9f9bc53fa13a0926533ef4d20397207e212c2086cbe13db5470fd29616abd35326d33090\",\n                \"txid\": \"c698ac4b4a61c90b2c93dababde867dea359f971e2efcf415c37c9a4d9c4f312\",\n                \"value_hash\": \"dbbdedc2b81d875403cc76486625a19f1e3b3c6f\",\n                \"vtxindex\": \"63\"\n            }\n        ],\n        \"383270\": [\n            {\n                \"address\": \"1KVzcgurJmTr4Cr44h6raEVtoGhm7ZZxzm\",\n                \"importer\": \"76a9143e2b5fdd12db7580fb4d3434b31d4fe9124bd9f088ac\",\n                \"importer_address\": \"16firc3qZU97D1pWkyL6ZYwPX5UVnWc82V\",\n                \"sender\": \"76a914caee018147f2d5ff32ca3b2ef35c17755bce440e88ac\",\n                \"sender_pubkey\": \"0411d88aa37a0eea476a5b63ca4b1cd392ded830865824c27dacef6bde9f9bc53fa13a0926533ef4d20397207e212c2086cbe13db5470fd29616abd35326d33090\",\n                \"txid\": \"7cfdfcf0c0abac9641ed5e253e7ba2b3ddabbc0b15302a4fc138519dd028d3ea\",\n                \"value_hash\": \"dbbdedc2b81d875403cc76486625a19f1e3b3c6f\",\n                \"vtxindex\": 234\n            }\n        ]\n    },\n    \"importer\": \"76a9143e2b5fdd12db7580fb4d3434b31d4fe9124bd9f088ac\",\n    \"importer_address\": \"16firc3qZU97D1pWkyL6ZYwPX5UVnWc82V\",\n    \"last_renewed\": 373622,\n    \"name\": \"judecn.id\",\n    \"op\": \";\",\n    \"op_fee\": 100000.0,\n    \"opcode\": \"NAME_IMPORT\",\n    \"preorder_block_number\": 373622,\n    \"revoked\": false,\n    \"sender\": \"76a914395f3643cea07ec4eec73b4d9a973dcce56b9bf188ac\",\n    \"sender_pubkey\": \"0411d88aa37a0eea476a5b63ca4b1cd392ded830865824c27dacef6bde9f9bc53fa13a0926533ef4d20397207e212c2086cbe13db5470fd29616abd35326d33090\",\n    \"txid\": \"1510e1582f48c7ea1c57156e6ac5ae0d2c0960cfb4d17db0860e140f6900beed\",\n    \"value_hash\": \"dbbdedc2b81d875403cc76486625a19f1e3b3c6f\",\n    \"vtxindex\": 108\n}\n```\n\nIn this example, we look up a name that does not exist:\n\n```\n$ blockstore-cli get_name_blockchain_record nonexistent.id\n{\n    \"error\": \"Not found.\"\n}\n```\n\n### Listing Names\n\nBlockstore can serve a listing of all the name metadata it knows about.  To do so, the command is:\n\n```\n$ blockstore-cli get_all_names\n```","name-pricing":"# Name Pricing\n\nNamespaces exist to set fees and lifetimes for the sets of names they contain.  Namespace prices are characterized by orders of magnitude, determined by the namespace's creator.  To price names, each namespace defines a set of 16 price \"buckets\" that characterize the order of magnitude of the price of of 1-character names, 2-character names, etc., with the 16th bucket serving as a catch-all for names with at least 16 characters.  The absense of vowels and the presence of non-alpha characters add multiplicative discounts to the name's price.  The price is calculated as follows:\n\n* Let `B` be the namespace's \"base price\".\n* Let `K` be the namespace's constant price multiplier.\n* Let `L` be the length of the name.\n* Let `N[L-1]` be the bucket that the name falls into (i.e. the price's order of magnitude).\n* Let `V` be the discount for having no vowels (it is set to 1 for names with vowels).\n* Let `A` be the discount for having non-alphabet characters (it is set to 1 for names with only alphabetical characters).\n\nThen, the price of a name is calculated as `(K * (B ** N[L-1])) / (max([1, V, A]))`.  The units are in uBTC.\n\n#### Example\n\nThe pricing of the `id` namespace (specified in Bitcoin transaction `ab54b1c1dd5332dc86b24ca2f88b8ca0068485edf0c322416d104c5b84133a32`) is as follows:\n\n* K = 250 \n* B = 4 \n* N = [6, 5, 4, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n* V = 10\n* A = 10\n\nThen, the following prices hold:\n\n* The price of `a.id` is `(250 * (4**6)) / (max([1, 1, 1])) = 1024000 uBTC`, or 1.024 BTC.\n* The price of `1.id` is `(250 * (4**6)) / (max([1, 10, 10])) = 102400 uBTC`, or 0.1024 BTC.\n* The price of `abc.id` is `(250 * (4**4)) / (max([1, 1, 1])) = 64000 uBTC`, or 0.064 BTC.\n* The price of `bcd.id` is `(250 * (4**4)) / (max([1, 10, 1])) = 6400 uBTC`, or 0.0064 BTC.\n* The price of `judecn.id` is `(250 * (4**1)) / (max([1, 1, 1]) = 1000 uBTC`, or 0.001 BTC.\n* The price of `j00dcn.id` is `(250 * (4**1)) / (max([1, 10, 10]) = 100 uBTC`, or 0.0001 BTC.\n* The price of `swiftonsecurity.id` is `(250 * (4**0)) / min([1, 1, 1])` = 250 uBTC, or 0.00025 BTC.\n\n### Namespace Pricing\n\nNamespaces are not free; their price is a function of their length.  Blockstore enforces the following pricing rules on creating namespaces:\n\nNamespace ID length | Cost (in BTC)\n------------------- | -------------:\n1                   | 400.0\n2, 3                | 40.0\n4, 5, 6, 7          | 4.0 \n8 and up            | 0.4\n\nNamespace creation fees are sent to the Blockstore burn address (`1111111111111111111114oLvT2`).  The price of a namespace can be queried with `blockstore-cli` via the `get_namespace_cost` command:\n\n```\n$ blockstore-cli get_namespace_cost <namespace ID>\n```","name-records":"# Name Records\n\nUpdating a profile from `blockstore-cli` is a matter of giving Blockstore the JSON document that represents the new profile information.  Blockstore will put the new profile hash into the blockchain, and upload the JSON document to the DHT and all other storage providers the `blockstore-cli` tool has been configured to use.\n\nBecause this operation writes data to the blockchain, the effect of the `update` will not become visible until six subsequent blocks have been mined.  The cost of the `update` operation is simply the cost of writing the requisite outputs to the blockchain as dust, plus mining fees.\n\nGiven the nature of this operation, the write to the blockchain must precede the write to the name owner's storage providers.  In the event that the write to the blockchain fails, no data will be uploaded to any storage providers.  In the event that the write to the blockchain succeeds (i.e. the transaction gets accepted) but the upload fails, the name owner can attempt to re-upload the JSON without issuing a new transaction by submitting the transaction ID along with the `update` command.  The transaction ID is used to prove to the storage providers that the write has been paid for by the writer.\n\nThe usage of this operation is as follows:\n\n```\n$ blockstore-cli update <name.namespace> <JSON string> <privatekey> [txid]\n```\n\n#### Example\n\nSuppose the owner of the name `swiftonsecurity.id` wanted to add a minimal profile, encoded as `{\"name\":{\"formatted\":\"Swift on Security\"},\"v\":\"2\"}`.  To do so, the command would be:\n\n```\n$ blockstore-cli update swiftonsecurity.id '{\"name\":{\"formatted\":\"Swift on Security\"},\"v\":\"2\"}' 5JZAZzZo5JvCEc4x9pkNAdkLf468H4KVMMhrwcv6WKFJ9x3ZC7m\n```\n\nNote that the private key used (`5JZAZzZo5JvCEc4x9pkNAdkLf468H4KVMMhrwcv6WKFJ9x3ZC7m`) has the address `199VaCaC9p95otia9e2EH7i6yZq7EWJHk2`, which is the registration address submitted for `swiftonsecurity.id` in the earlier registration example (not to be confused with the preorder key pair).\n\nNow, suppose that the update transaction succeeded as transaction ID `cd08dd0afff9838ede0b8f4e3a9ffbe95e1c81d7da1a38582b3ce93ad10f5e5a`, but uploading `{\"name\":{\"formatted\":\"Swift on Security\"},\"v\":\"2\"}` to the DHT failed.  The owner of `swiftonsecurity.id` can re-run the upload with:\n\n```\n$ blockstore-cli update swiftonsecurity.id '{\"name\":{\"formatted\":\"Swift on Security\"},\"v\":\"2\"}' 5JZAZzZo5JvCEc4x9pkNAdkLf468H4KVMMhrwcv6WKFJ9x3ZC7m cd08dd0afff9838ede0b8f4e3a9ffbe95e1c81d7da1a38582b3ce93ad10f5e5a\n```","name-registrations":"# Name Registrations\n\nRegistering a new name is a two-step process:  it must first be *preordered*, and then *registered.*  Only the principal who preordered the name can register it.  This is done as an anti-squatting measure, in order to stop someone from stealing a name while it is being propagated through the network.\n\nA name owner can have multiple names.  The current limit is 25 per key pair, but this is arbitrary.\n\nEach name in Blockstore is part of a *namespace*.  The name identifies the namespace it belongs to by ending in \".<namespace ID>\".  For example, the name `swiftonsecurity.id` belongs to the `id` namespace.\n\nIn order to register a name, the namespace must exist and be open to name registration.  You can confirm this with the `get_namespace_blockchain_record` command, as follows:\n\n```\n$ blockstore-cli get_namespace_blockchain_record <namespace ID>\n```\n\nThis command will succeed only if the namespace is ready.  More details on namespaces can be found in the **Namespaces** section.\n\n### Name Preorders\n\nTo preorder a name, a name owner needs *two* sets of key pairs:  one to preorder, and one to register.  The *second* key pair should be brand-new and known only to the name owner.  The second key pair's address does not need any Bitcoin, but the name owner will need to transfer some to it once it is necessary to update the name's profile.  The secrecy of the second key pair is important, because Blockstore uses its address as a cryptographic hash salt to blind would-be name squatters.  Once registered, the name will be controlled by the *second* key pair.\n\nThe name owner pays for the name by preordering it using the *first* key pair, since only the name owner will be able to claim it.  The amount paid can be determined with the `get_name_cost` command:\n\n#### Example\n\n```\n$ ./blockstore-cli get_name_cost swiftonsecurity.id\n[\n    {\n        \"satoshis\": 25000\n    }\n]\n```\n\nThe fee will be sent from the address of the private key used to preorder the name.\n\nOnce the name owner has found a suitably-priced name, the `preorder` command can be used to preorder it.  It is used as follows:\n\n```\n$ blockstore-cli preorder <name.namespace> <preorder_privatekey> <register_address>\n```\n\nOnce preordered, the name owner must register the name within 144 blocks of the preorder (about 24 hours).\n\n#### Example\n\nThe following command will preorder the name `swiftonsecurity.id`, granting control of the name to the private key tied to the `register_address` (the 3rd argument).\n\n```\n$ blockstore-cli preorder swiftonsecurity.id 5KMKzs7grgyatKURCgxB7SgdeYu35poaEumJShLxPpLTBCrpy8o 199VaCaC9p95otia9e2EH7i6yZq7EWJHk2\n```\n\nNote that the address of `5KMKzs7grgyatKURCgxB7SgdeYu35poaEumJShLxPpLTBCrpy8o` is `1HYWB9R8ZKXVfEUstJAPhdkJ3nRpc2KHCM`, while the private key of address `199VaCaC9p95otia9e2EH7i6yZq7EWJHk2` is actually `5JZAZzZo5JvCEc4x9pkNAdkLf468H4KVMMhrwcv6WKFJ9x3ZC7m`.  Address `1HYWB9R8ZKXVfEUstJAPhdkJ3nRpc2KHCM` will be charged 25000 satoshis (sent to the burn address `1111111111111111111114oLvT2`), plus mining fees and dust fees.\n\nThe result of the command will contain the transaction ID in Bitcoin, which the name owner can monitor to ensure that the rest of the Bitcoin network accepts the preorder transaction.  We advise the name owner to wait for six confirmations before the registering the name.\n\n### Name Registrations\n\nThe name owner should wait for at least six transaction confirmations to ensure that the preorder was accepted.  Once it has been accepted, the name owner must use the preorder key pair to register the name, and reveal the address of the new public key that will control it.\n\nThis is achieved with the `register` command:\n\n```\n$ blockstore-cli register <name.namespace> <preorder_privatekey> <register_address> \n```\n\nThis will create an empty profile for the name owner, and reveal to the world the name owner's new name, Bitcoin address, and preorder public key.\n\n#### Example\n\nTo register the preordered name `swiftonsecurity.id`, the name owner would run the following command:\n\n```\n$ blockstore-cli register swiftonsecurity.id 5KMKzs7grgyatKURCgxB7SgdeYu35poaEumJShLxPpLTBCrpy8o 199VaCaC9p95otia9e2EH7i6yZq7EWJHk2\n```\n\nThe result of the command will contain the transaction ID in Bitcoin, which the name owner can monitor to ensure that the rest of the network accepts the register transaction.  The cost of registering is simply the cost of the mining fee and dust fees for each output.","name-renewals":"# Name Renewals\n\nIn most namespaces, names have finite lifetimes and will eventually expire.  Exactly when is determined by the rules of the namespace, but a name is be said to have expired by a certain block number.  After this point, the name can be preordered and registered by someone else.  If the name owner wants to avoid this, the name must be *renewed*.\n\nWhen a name is renewed, its lifetime is reset to the maximum lifetime defined by the namespace.  Some namespaces allow names to have infinite lifetimes, in which case no renewal is necessary.\n\nThe fee to renew the name is determined by the rules of the namespace, but it is the same fee paid at registration.  The cost to renew can be obtained with the `get_name_cost` operation as before.\n\nThe following command invocation will renew a name:\n\n```\n$ blockstore-cli renew <name.namespace> <name owner&#39;s private key>\n```\n\n#### Example\n\nThis command will renew the name `swiftonsecurity.id`.  The owner of the address `199VaCaC9p95otia9e2EH7i6yZq7EWJHk2` will continue to own it for another 52595 blocks.\n\n```\n$ blockstore-cli renew swiftonsecurity.id 5JZAZzZo5JvCEc4x9pkNAdkLf468H4KVMMhrwcv6WKFJ9x3ZC7m\n```\n\nNote that the private key used has the address `199VaCaC9p95otia9e2EH7i6yZq7EWJHk2`, which is the registration address used in the earlier example (not to be confused with the preorder pair).","name-transfers":"# Name Transfers\n\nThis page shows how to transfer a name to a new owner.  You will need to have installed the [blockstore-client](https://github.com/blockstack/blockstore) package, and will need access to a full Blockstore node.\n\n**WARNING:** Transferring a name cannot be undone.  Once transferred, only the new owner will be able to transfer it.\n\n### Requirements\n\nTo transfer a name to a new owner, you will need:\n\n* your private key\n* the recipient's address\n\n### Transferring\n\nThe command format to transfer a name is as follows:\n\n```\n$ blockstore-cli transfer <name.namespace> <recipient address> <keep data?> <privatekey>\n```\n\nYou have the option to transfer your profile data to the new owner, as well as the name.  This is controlled by typing `True` or `False` into the `<keep data?>` field.  If you are unsure, you should pass `False`.  This is because it is **not** recommended that you transfer your profile, since the new name owner could use it to impersonate you.\n\nWhen the command runs successfully, it will return a JSON object with at least the following fields given:\n\n```\n{\n   \"transaction_hash\": <the transaction ID on the blockchain that contains this transfer>\n   \"data\": <the OP_RETURN data>\n}\n```\n\nOn error, an `error` field will be present, and it will contain a descriptive error message.\n\n#### Example\n\nSuppose the owner of `swiftonsecurity.id` wanted to transfer her name (but **not** her profile data) to the address `1NMkY7MThPGWgrHZWfp6uwP5PqyfF8i86R`.  Suppose that her private key is `5JZAZzZo5JvCEc4x9pkNAdkLf468H4KVMMhrwcv6WKFJ9x3ZC7m`.  Then, to do so, she would run:\n\n```\n$ blockstore-cli transfer swiftonsecurity.id 1NMkY7MThPGWgrHZWfp6uwP5PqyfF8i86R False 5JZAZzZo5JvCEc4x9pkNAdkLf468H4KVMMhrwcv6WKFJ9x3ZC7m\n```\n\nIf the command succeeds, it might print something like this:\n\n```\n{\n    \"transaction_hash\": \"269874f5a3847e0e869c982b5edfcb3a77b26f04dcfcfc0bdf1c75cf8fbacf35\", \n    \"data\": \"69643e7e7727f568dd9d36d5c777c024da599473a94e23658c0ee8424b78034cc72ebbb7\"\n}\n```\n\n### Interpreting the OP_RETURN data\n\nIf you look closely at `data`, you'll see that the first four bytes (`69643e7e`) decode to the ASCII string `id>~`.  This specifically indicates a `NAME_TRANSFER` operation (represented by `id>`), where the profile data was *not* preserved (represented by `~`).  Had the user passed `True`, then the first four bytes would be `69643e3d`, or `id>>` in ASCII (where the second `>`) indicates that the profile record should be preserved\n\n### Troubleshooting\n\nThe only way this command can fail is if there was a blockchain-level problem.  If the transaction did not go through to the underlying blockchain, follow the advice in the \"Rejected Transactions\" section of [[Commands don't Work]].\n\n### Name was sent to the wrong address\n\nUnfortunately, there is nothing to do but wait for the name to expire.  The fact that Blockstore prevents other users from taking your name by force also means that it prevents everyone except for the private key owner from issuing transfers.  **You should be absolutely certain that you have the right recipient address**.\n\n### My name was transferred, but I did not do it.\n\nThis usually means someone has stolen your private key.  See the [[Private Key Lost or Stolen]] page.\n\n### Transfering\n\nNames do not need to stay bound to the same owner indefinitely.  Instead, the name owner can opt to transfer it to a new owner.  The name owner can also opt to disable the name entirely by revoking it, thereby denying all future modifications to it until it expires.\n\n### Transferring Names\n\nOnce a name has been registered, its owner can opt to transfer it to another address (i.e. another key pair).  This can be performed with the `transfer` command.\n\nThe name owner has the option of transferring the name's profile information along with the name.  If transferred, the profile content will be controllable only by recipient--the sender will be unable to update the data via Blockstore, and Blockstore will use the recipient's public key to authenticate data.  There are benefits and drawbacks to doing so depending on the circumstances, so we leave the choice to the users.  It is recommended to *not* transfer the profile information when transferring a name, since the recipient retains the option to rebuild the profile from the sender's profile at a later date.\n\nThe following command invocation will transfer a name, but not the profile data.  The third argument controls whether or not to transfer the profile.\n\n```\n$ blockstore-cli transfer <name.namespace> <recipient's Bitcoin address> False <name owner's private key>\n```\n\nThe following command invocation will transfer a name *and* the profile data.\n\n```\n$ blockstore-cli transfer <name.namespace> <recipient's Bitcoin address> True <name owner's private key>\n```\n\n#### Example\n\nThis command will transfer ownership of `swiftonsecurity.id` to the owner of the address `16firc3qZU97D1pWkyL6ZYwPX5UVnWc82V`:\n\n```\n$ blockstore-cli transfer swiftonsecurity.id 5JZAZzZo5JvCEc4x9pkNAdkLf468H4KVMMhrwcv6WKFJ9x3ZC7m 16firc3qZU97D1pWkyL6ZYwPX5UVnWc82V\n```\n\nNote that the private key `5JZAZzZo5JvCEc4x9pkNAdkLf468H4KVMMhrwcv6WKFJ9x3ZC7m` is the private key that owns the name, since its address (`199VaCaC9p95otia9e2EH7i6yZq7EWJHk2`) was the registration address in the earlier registration example (not to be confused with the preorder key pair).\n\n### Notes on Transferring Names\n\nWe anticipate that a secondary market for existing names could form around this feature.  If so, we offer the following advice to buyers:\n\n* Check the revocation status of a name before buying.  If it is revoked, it is worthless.\n* Check that the name is not going to expire anytime soon--at least not for 30 blocks.  This is because the new owner should wait for at least six confirmations to transfer, and at least another six for the renewal fee to be processed.  The time between blocks is not guaranteed to be 10 minutes.\n* Use the `get_name_cost` command to learn the actual worth of the name.\n* Make sure the name's namespace is ready for registrations--it must show up with the `lookup_namespace` command.\n","namespaces":"# Namespaces\n\nBlockstore organizes names into namespaces.  A name's namespace can be identified by looking at the characters after the last '.' in the name.\n\n### Creating a Namespace\n\nCreating a namespace is a 4-step process:\n\n* Preordering a namespace\n* Revealing a namespace \n* Importing names into the namespace \n* Opening the namespace for registration\n\nBefore the namespace is open for registration, the namespace creator has the power to define the namespace ID, its pricing parameters, and add an initial set of names.  Once the namespace is opened for registration, anyone can create names within the namespace, subject to pricing and availability.\n\nJust as how Blockstore requires name owners to preorder and then register a name, it also requires namespace creators to preorder and then reveal namespaces.  Preordering a namespace requires the namespace creator to have two key pairs: one for preordering the namespace, and one for revealing it.  The reason for this is to stop a would-be namespace squatter from stealing the namespace as it is revealed--by design, the squatter cannot see the name of the namespace until after it has been preordered.  As such, it is important that the revealing key pair be *known only to the namespace creator*.\n\nThe command to pre-order a namespace is:\n\n```\n$ blockstore-cli namespace_preorder <namespace ID> <preorder private key> <reveal_address>\n```\n\n#### Example\n\nThe following command will preorder the namespace `abc`, granting control of the name to the private key tied to the `reveal_address` (the 3rd argument).\n\n```\n$ blockstore-cli namespace_preorder abc 5KMKzs7grgyatKURCgxB7SgdeYu35poaEumJShLxPpLTBCrpy8o 199VaCaC9p95otia9e2EH7i6yZq7EWJHk2\n```\n\nNote that the address of `5KMKzs7grgyatKURCgxB7SgdeYu35poaEumJShLxPpLTBCrpy8o` is `1HYWB9R8ZKXVfEUstJAPhdkJ3nRpc2KHCM`, while the private key of address `199VaCaC9p95otia9e2EH7i6yZq7EWJHk2` is actually `5JZAZzZo5JvCEc4x9pkNAdkLf468H4KVMMhrwcv6WKFJ9x3ZC7m`.  Address `1HYWB9R8ZKXVfEUstJAPhdkJ3nRpc2KHCM` will be charged 40 BTC (sent to the burn address `1111111111111111111114oLvT2`), plus mining fees and dust fees.\n\nThe result of the command will contain the transaction ID in Bitcoin, which the namespace creator can monitor to ensure that the rest of the Bitcoin network accepts the preorder transaction.  We advise the namespace creator to wait for six confirmations before the revealing the namespace.\n\n### Revealing a Namesace\n\nOnce a namespace has been preordered, the creator (and only the creator) can reveal it.  In doing so, the creator sets the lifetime for each name in the namespace, as well as all of the pricing parameters (K, B, N, V, and A).\n\n**Caveat**: Once a namespace is revealed, its properties are set forever.\n\nThe command to do so is:\n\n```\n$ blockstore-cli namespace_reveal <namespace ID> <reveal_address> <lifetime_in_blocks> <K> <B> <N> <A> <V> <preorder private key>\n```\n\nThe cost of revealing a namespace is simply the mining fee plus the dust fees for each output.\n\n#### Example\n\nSuppose the namespace creator of `abc` wanted each name to cost at least 200 uBTC, and for name prices to vary by powers of 10.  Suppose that the desired pricing rule was that all names between lengths 1 and 10 would cost 20 BTC, and all names greater than length 8 would cost 2 BTC.  Suppose that names could receive a 50-fold discount if they had no vowels, and a 100-fold discount if they had numbers or punctuation.  Suppose also that names were supposed to expire after 3 years.  To reveal the namespace with these properties, the namespace creator would issue the command:\n\n```\n$ blockstore-cli namespace_reveal abc 199VaCaC9p95otia9e2EH7i6yZq7EWJHk2 157788 200 10 4,4,4,4,4,4,4,4,3,3,3,3,3,3,3,3 100 50 5KMKzs7grgyatKURCgxB7SgdeYu35poaEumJShLxPpLTBCrpy8o\n```\n\n### Importing Names\n\nAfter the namespace is revealed, the namespace creator has the opportunity to populate the namespace with names.  In doing so, the creator registers the name for a particular address and assigns it the hash of its profile.  This way, when the namespace is ready for registration, the names are already owned by their respective owners.\n\nThe command to import a name is:\n\n```\n$ blockstore-cli name_import <name.namespace> <name owner's address> <name owner's profile hash> <name revealer private key>\n```\n\nThe fourth argument is the private key meant for revealing names, whose address was used as the revealer address when preordering and revealing the namespace.  This private key is *not* the one used to preorder and reveal the namespace.\n\nThe cost of importing names is just the cost of the mining fees, plus the dust cost for each output.  Importantly, the namespace creator does *not* pay the name's price when importing names.\n\n#### Example\n\nSuppose the creator of `abc` wanted to import the name `swiftonsecurity.abc`, and have it be owned by the owner of the address `199VaCaC9p95otia9e2EH7i6yZq7EWJHk2`.  Suppose the owner had a name profile with hash `8b3fe3a9ecb162cb7968d5a889fbf159c9f317cb`.  To import this name, the namespace creator would issue the command:\n\n```\n$ blockstore-cli name_import swiftonsecurity.abc 199VaCaC9p95otia9e2EH7i6yZq7EWJHk2 8b3fe3a9ecb162cb7968d5a889fbf159c9f317cb 5JZAZzZo5JvCEc4x9pkNAdkLf468H4KVMMhrwcv6WKFJ9x3ZC7m\n```\n\nThen, when the namespace is ready, only the owner of `199VaCaC9p95otia9e2EH7i6yZq7EWJHk2` will be able to update, transfer, or revoke the name `swiftonsecurity.abc`.\n\n### Notes on Importing Names\n\n* A namespace must be ready no later than 52596 blocks after they are revealed.  Otherwise, it expires, as well as all of its imported names.  Namespace creators should calculate how long it will take to import all names *before* creating the namespace.\n* Sometimes, there can be a lot of names to reveal at once, and revealing them all in sequence can be prohibitively time-consuming.  To address this, Blockstore will accept name imports that have come from one of up to 300 unhardened hierarchical deterministic (HD/BIP32) key pairs derived from the name revealer private key.  Each key pair's wallet can be loaded with BTC, and each used to import a disjoint subset of names concurrently.\n* Sometimes, the namespace creator will need to update an already-imported name.  For example, the name owner might disagree with the namespace creator as to what the hash of the profile is.  To address this, Blockstore honors the *last-seen* copy of a name import whenever there is a conflict.  The namespace creator can overwrite old name imports this way until the namespace is declared ready.\n\n### Making the Namespace Ready\n\nOnce the namespace creator is satisfied with the state of the namespace, it can be made ready for registration by the public.  Once this happens, the namespace creator will no longer have the power to alter the set of names in the namespace, except for the ones (s)he owns (and (s)he is limited to 25 names by the Blockstore implementation).\n\nIn order to make the namespace ready, the namespace creator issues the `namespace_ready` command:\n\n```\n$ blockstore-cli namespace_ready <namespace ID> <revealer private key>\n```\n\nNote that the private key is the *revealer* private key, not the preorder pirvate key.\n\nOnce accepted and recognized by Blockstore, the namespace will be open for registration--anyone will be able to preorder and register currently-unclaimed names.\n\nThe cost of making a namespace ready is simply the mining fee plus the dust cost of each output.\n\n#### Example\n\nTo make the namespace `abc` ready, the namespace creator would run:\n\n```\n$ blockstore-cli namespace_ready abc 5JZAZzZo5JvCEc4x9pkNAdkLf468H4KVMMhrwcv6WKFJ9x3ZC7m\n```","troubleshooting":"# Troubleshooting\n\nBecause Blockstore is a wide-area distributed system, there can be many sources of problems.  The common ones are documented here.  If you are encountering a problem with Blockstore that is not listed here, please join our [Slack](https://blockstack.slack.com) and let us know, or email us directly.\n\n### Network-level Errors\n\nNetwork-level errors are usually transient, and should not affect the correctness of the system beyond preventing Blockstore from learning the latest name updates.\n\n### Symptoms and Diagnosis\n\n* **Symptom:** You see error messages in the log in the form of `gaierror: <something something something>`\n  * **Diagnosis:** There is probably something wrong with your network.  Make sure you can use DNS, and make sure you have network connectivity.  Use `ping` and `dig` to see that you can resolve hostnames and reach hosts.\n* **Symptom:** You see error messages in the log in the form of `SSLError: <something something something>`\n  * **Diagnosis:** Your network is working, but Blockstore is having trouble communicating with the `bitcoind` node.  If you have `bitcoin-cli` installed, try using it to ping the node.  If you are using Onename's bitcoind fleet, the exact command is:\n\n  ```\n  $ bitcoin-cli -rpcconnect=btcd.onename.com -rpcusername=openname -rpcpassword=opennamesystem -rpcssl ping\n  ```\n\n### Database errors\n\n* **Symptom:** You see different consensus hashes and even different names than your peers.\n  * **Diagnosis:** It is possible that you are on a fork of the blockchain.  First, compare your `~/.blockstore/blockstore.snapshots` file to that of someone you trust.  Do they match up until a particular block number (beyond 373601), and then diverge?  If so, then this means one of two things:\n      * If you recently upgraded your Blockstore, you might still have an old one running.  If so, then the old one could have overwritten the `blockstore.db` and `blockstore.snapshots` files with its own copies, which may not store the same information as you expect\n      * The blockchain itself forked, and both you and your friend were on separate forks.  If this is the case, then please see the [[Blockchain Fork Recovery]] page for how to proceed.\n\n### Python-level errors\n\nThe Python runtime environment is extremely well-tested, but some of us have encountered problems with it in the past.\n\n* **Symptom:** Blockstore causes a segmentation fault, and you see some instances of `error: [Errno 32] Broken pipe` that follow.\n  * **Diagnosis:** This is probably a bug in Python's `multiprocess` module or some library on which it depends.  The best advice we can give is to make sure you are running the latest version of Python 2 branch, and your OS is up-to-date.  The only solution here is to run `blockstored stop` to clean up, and then restart blockstore.\n* **Symptom:** Blockstore throws an exception that is not described in this document\n  * **Diagnosis:** There's a bug in Blockstore.  Please post a copy of the exception [here](https://github.com/blockstack/blockstore/issues), so we can get back to you and fix it.\n\n### Rejected Transactions\n\nIf `blockstore-cli` fails to send the transaction, then no money will be spent from your wallet, you will not see a `transaction_hash` in the command output, and your profile will not be affected at all.  However, you will need to find out why:\n\n* **Are you using the right private key?**  If you send a transaction with the wrong private key, it might not have any funds associated with it.\n* **Make sure you have enough BTC in your wallet.** Updating, transferring, and revoking a name only costs as much as the dust fee and miners fees, but you will need the funds to be present and confirmed by the miners first.\n* **Make sure you have no unconfirmed transactions.** A lot of miners won't accept transactions that have unconfirmed unspent outputs. Try waiting about an hour and try again, to make sure that all your unconfirmed transactions get accepted onto the main blockchain.\n* If you are using a subsidized transaction from Blockstore, **try waiting 30 minutes and asking for a new one.**  It is possible that the Blockstore operator's node is misconfigured, or its UTXO provider did not supply the right unspent outputs for your address.  If the problem persists, you may need to contact the operator.\n* If all else fails, **try configuring Blockstore to use a different UTXO provider.** Sometimes, a UTXO provider won't see your unspent outputs for some time.\n\n### Rejected Name Operations\n\nSometimes a transaction will be successfully written to the blockchain, but Blockstore will reject it.  You can tell whether or not Blockstore rejected a transaction by searching for it in the logfile (by default, this is `~/.blockstore/blockstore.log.indexer`).  If this happens to you, it might be for the following reasons:\n\n* **Did you use the right private key?**  If you send a Blockstore operation with the wrong private key, Blockstore will not accept it.  This is because only a particular principal (or set of principals) can control a name or namespace.  Refer to the documentation on the specific command to see which private key(s) are required.\n* **Was there a delay in sending the transaction?** Some transactions (like name updates) must be sent and discovered by Blockstore within a limited amount of time.  In the unlikely case that this doesn't happen for you, you will need to re-send the transaction.  It is best to try to find out why your transaction took so long to get incorporated into the blockchain, because it may happen again (examples:  the miner you contacted was on a shorter fork; the blockchain is experiencing very high load, etc.).\n* **Is Blockstore scanning a different blockchain fork?**  Sometimes the blockchain can fork, and the Blockstore node that sent your transaction originally might be on a different fork than you.  This means that its view of the world will diverge from all the other Blockstore nodes.  If you are running a Blockstore node and this happens, please refer to the [[Blockchain Fork Recovery]] section.\n","virtual-blockchain":"# Virtual Blockchain\n\nWe introduce the notion of a virtual blockchain as operations defined by a higher-layer protocol that are stored in transactions in a standard blockchain. If you throw away all other data (transactions that have no operations for the higher-layer protocol) and extract the operations, they form a logical chain in a linear fashion just like the underlying blockchain. From this, nodes read the sequence and interpret them with a set of defined rules, building a view of the system that should be in sync.\n\n### Layer 2\n\nAbove the blockchain is a virtual blockchain, also called virtualchain. Only Blockstore nodes are aware of this layer and underlying blockchain nodes are agnostic to it. Blockstore operations are defined in the virtualchain layer and are encoded in valid blockchain transactions as additional metadata. Blockchain nodes do see the raw transactions, but the logic to process Blockstore operations only exists at the virtualchain level.\n\nThe rules for accepting or rejecting Blockstore operations are also defined in the virtualchain. Accepted operations are processed by the virtualchain to construct a database that stores information on global state of the system along with state changes at any given blockchain block. Virtualchains can be used to build a variety of state machines. Currently, Blockstore defines only a single state machine; a global naming system."}