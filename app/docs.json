{"blockchain-auth":"# Blockchain Profile\n\n## Overview\n\n1. the app creates a signed authentication request and delivers it to the user\n1. the user's client verifies the authenticity of the request\n1. the user's client compiles information for an authentication response\n    1. it grabs the challenge inside of the request\n    1. it looks at the permissions and pulls together the necessary data to deliver\n1. the user's client creates a signed authentication response with the compiled information\n1. the user's client sends a message to the app's server with both the app-produced authentication request and the user-produced authentication response\n1. the app looks at the request and response and performs a few checks\n    1. \"hey, this auth request was really signed by me\"\n    1. \"hey, this auth response was really signed by the user who claims to have produced the token\"\n    1. \"hey, the request and response have the same challenge\"\n1. the app logs the user in\n\n## Auth Requests\n\n### Request Format\n\n```json\n{\n    \"header\": {\n        \"typ\": \"JWT\",\n        \"alg\": \"ES256\"\n    },\n    \"payload\": {\n        \"issuedAt\":\"1440624435.28\",\n        \"challenge\":\"8befe9e5-db3a-408a-aaae-c41c1c8eee55\",\n        \"permissions\":[\"blockchainid\"],\n        \"issuer\": {\n            \"publicKey\":\"0231e4873b5569c5811b4849cf1797f2bff3dab358b07416aa7a9af638f7182ca3\",\n            \"domain\":\"onename.com\"\n        }\n    },\n    \"signature\": \"MEUCIQDzUaSrgTR_tTpNSVcitKYvYWd3bc3uylMe3xCfo-QclQIgDLN1hgXSyqiEk0AGQ21XB2wzuqrotTmE_yN3pn4f_38\"\n}\n```\n\n### Request Types\n\nThere are two types of auth requests: signed requests and unsigned requests.\n\nSigned requests are by far the norm and should be required for any app that has a server that can store private keys and sign messages. The majority of web apps, mobile apps and desktop apps that require user authentication will fall into this category.\n\nUnsigned requests are very specific type of auth request where the request is coming from a desktop app or mobile app that does not have any server that can sign messages. An example of this would be a peer-to-peer commerce app.\n\nUnsigned requests do not require verification and instead have a unique authentication method as follows:\n\n1. the desktop app sends a request that includes an identifier that uniquely identifies the client software on the P2P network\n2. the user takes the identifier, visually makes sure it was the same identifier that was shown in the original app, and publicly posts it in his/her profile to demonstrate access to the blockchain ID\n\n### How Signed Request Verification Works\n\nTwo steps are required to verify a signed auth request:\n\n1. verification that the token is a valid JWT that was signed by the specified public key\n2. verification that the specified public key is included in the DKIM records of the specified domain\n\n### Permission Types\n\n+ read public data\n    + blockchain ID and entire public profile\n+ read private data\n    + name\n    + profile photo\n    + bio\n    + website\n    + city of residence\n    + social accounts\n    + email\n    + birthday\n    + postal address\n    + bitcoin address\n    + credit card number\n    + friends\n    + photos\n+ write public data\n    + write access to a section set aside for the app\n+ write private data\n    + friends\n    + photos\n\n\n## Auth Responses\n\n### Response Format\n\n```json\n{\n    \"header\": {\n        \"typ\": \"JWT\",\n        \"alg\": \"ES256\"\n    },\n    \"payload\": {\n        \"issuedAt\": \"1440713414.85\",\n        \"challenge\": \"7cd9ed5e-bb0e-49ea-a323-f28bde3a0549\",\n        \"issuer\": {\n            \"publicKey\": \"03fdd57adec3d438ea237fe46b33ee1e016eda6b585c3e27ea66686c2ea5358479\",\n            \"blockchainid\": \"ryan\",\n            \"publicKeychain\": \"xpub661MyMwAqRbcFQVrQr4Q4kPjaP4JjWaf39fBVKjPdK6oGBayE46GAmKzo5UDPQdLSM9DufZiP8eauy56XNuHicBySvZp7J5wsyQVpi2axzZ\",\n            \"chainPath\": \"bd62885ec3f0e3838043115f4ce25eedd22cc86711803fb0c19601eeef185e39\"\n        }\n    },\n    \"signature\": \"MEUCIQDzUaSrgTR_tTpNSVcitKYvYWd3bc3uylMe3xCfo-QclQIgDLN1hgXSyqiEk0AGQ21XB2wzuqrotTmE_yN3pn4f_38\"\n}\n```\n\n### Response Types\n\nThere are two types of auth responses - pseudo-anonymous auth responses and identified auth responses.\n\nWith pseudo-anonymous auth responses, only a persistent public key is specified, as well as optional private information. No blockchain ID, and by extension public profile, is provided by the user.\n\nWith identified auth responses, the user additionally provides a blockchain ID, as well as evidence that they are the owner of said blockchain ID.\n\n### How Response Verification Works\n\nPseudo-anonymous auth response verification only requires a single step - verification that the token is a valid JWT that was signed by the specified public key.\n\nIdentified auth responses, meanwhile, require two additional verification steps:\n\n1. verification that the provided public keychain and chain path combo together can be used to derive the public key of the signer\n2. verification that the provided public keychain is explicitly specified by the user in his/her blockchain ID profile as a keychain that has authorization to perform authentication\n\nThe public keychain is verified against the chain path and public key in the following way:\n\n1. the chain path is split up into 8 32-bit pieces, which are each modded with 2^31, yielding 8 31-bit \"chain steps\"\n2. each chain step is used in succession to produce a child key from the previous parent key until a final child key (aka \"ancestor\" key) is produced\n3. the ancestor key is checked for equality with the public key of the signer\n\n## Code\n- [Blockchain Auth library, written in node.js](https://github.com/blockstack/blockchain-auth-js)  \n- [Blockchain Auth library, written in python](https://github.com/blockstack/blockchain-auth-python)  \n- [Agent for logging into websites with Blockchain Auth](https://github.com/blockstack/blockchain-auth-agent)  ","blockchain-profile":"# Blockchain Profile\n\n## Types\n\n### Person\n\n```js\nvar person = new Person()\nperson.setName(\"Naval\", \"Ravikant\")\nperson.setDescription(\"Co-founder of AngelList\")\nperson.setImage(\"avatar\", \"https://pbs.twimg.com/profile_images/3696617328/667874c5936764d93d56ccc76a2bcc13.jpeg\")\nperson.setSocialAccount(\"facebook\", \"navalr\", \"https://facebook.com/navalr/posts/10152190734077261\")\nperson.setSocialAccount(\"twitter\", \"naval\", \"https://twitter.com/naval/status/486609266212499456\")\nperson.setEmployer(\"angellist.id\", \"Angel List\")\nperson.setFriend(\"muneeb.id\", \"Muneeb Ali\")\nperson.setFriend(\"ryan.id\", \"Ryan Shea\")\nconsole.log(person.profile)\n{\n    \"@type\": \"Person\",\n    \"name\": \"Naval Ravikant\",\n    \"image\": [\n        {\n            \"@type\": \"ImageObject\",\n            \"name\": \"avatar\",\n            \"contentUrl\": \"https://pbs.twimg.com/profile_images/3696617328/667874c5936764d93d56ccc76a2bcc13.jpeg\"\n        }\n    ]\n    \"account\": [\n        {\n            \"@type\": \"Account\",\n            \"service\": \"facebook\",\n            \"identifier\": \"navalr\",\n            \"proofType\": \"http\",\n            \"proofUrl\": \"https://facebook.com/navalr/posts/10152190734077261\"\n        },\n        {\n            \"@type\": \"Account\",\n            \"service\": \"twitter\",\n            \"identifier\": \"naval\",\n            \"proofType\": \"http\",\n            \"proofUrl\": \"https://twitter.com/naval/status/486609266212499456\"\n        }\n    ],\n    \"worksFor\": [\n        {\n            \"@type\": \"Organization\",\n            \"name\": \"AngelList\",\n            \"id\": \"angellist.id\"\n        }\n    ],\n    \"knows\": [\n        {\n            \"@type\": \"Person\",\n            \"name\": \"Muneeb Ali\",\n            \"id\": \"muneeb.id\"\n        },\n        {\n            \"@type\": \"Person\",\n            \"name\": \"Ryan Shea\",\n            \"id\": \"ryan.id\"\n        }\n    ]\n}\n```\n\n### Organization\n\n```js\nvar organization = new Organization()\norganization.setName(\"AngelList\")\norganization.setEmployee(\"naval.id\", \"Naval Ravikant\")\nconsole.log(organization.profile)\n{\n    \"@type\": \"Organization\",\n    \"name\": \"AngelList\",\n    \"employee\": [\n        {\n            \"@type\": \"Person\",\n            \"name\": \"Naval Ravikant\",\n            \"id\": \"naval.id\"\n        }\n    ]\n}\n```\n\n### Creative Work\n\n```js\nvar creativeWork = new CreativeWork()\ncreativeWork.setName(\"Balloon Dog\")\ncreativeWork.setCreator(\"therealjeffkoons.id\", \"Jeff Koons\")\ncreativeWork.setDateCreated(\"May 9 1994\")\ncreativeWork.setDatePublished(new Date())\nconsole.log(creativeWork.profile)\n{\n    \"@type\": \"CreativeWork\",\n    \"name\": \"Balloon Dog\",\n    \"creator\": [\n        {\n            \"@type\": \"Person\",\n            \"name\": \"Jeff Koons\",\n            \"id\": \"therealjeffkoons.id\"\n        }\n    ],\n    \"dateCreated\": \"1994-05-09T00:00:00-0400\",\n    \"datePublished\": \"2015-12-10T14:44:26-0500\"\n}\n```\n\n## Registration\n\nFollow these steps to create and register a profile for a Blockchain ID:\n\n1. Create a JSON profile object\n2. Convert the profile object into tokens\n3. Create a zone file that points to the web location of the profile object\n\nBut first, import the required modules:\n\n```js\nvar BlockchainProfile = require('blockchain-profile').BlockchainProfile,\n    PrivateKeychain = require('keychain-manager').PrivateKeychain\n```\n\n### Create a Profile Object\n\nThe format for profile objects is based on the formatting found at schema.org.\n\n```js\nvar person = new Person()\nperson.setName(\"Satoshi\", \"Nakamoto\")\nperson.setFriend(\"gavinandresen.id\")\nconsole.log(person.profile)\n{\n    \"@type\": \"Person\",\n    \"givenName\": \"Satoshi\",\n    \"familyName\": \"Nakamoto\",\n    \"knows\": [\n        {\n            \"@type\": \"Person\",\n            \"id\": \"gavinandresen.id\"\n        }\n    ]\n}\n```\n\n### Create a Token File\n\n```js\nvar privateKeychain = new PrivateKeychain()\nvar tokenFile = signProfileTokens(profile, privateKeychain)\n```\n\n### Create a Zone File\n\n```js\nvar publicKeychain = privateKeychain.publicKeychain()\nvar hostUrls = ['https://s3.amazonaws.com/mq9/users/satoshi-nakamoto.json']\nvar checksums = [{ field: 'pgp[0].publicKey', hash: 'e508f0c2c455ab79a4fabc4b51aa537e123c08abee40a87c47e6705a2bbae4ae', algorithm: 'SHA256' }]\nvar zoneFile = createZoneFile('satoshi.id', publicKeychain, hostUrls, checksums)\n```\n\n### Reconstruct a Profile\n\n```js\nvar profile = getProfileFromTokens(tokenFile, publicKeychain)\nconsole.log(profile)\n{\n    \"@type\": \"Person\",\n    \"givenName\": \"Satoshi\",\n    \"familyName\": \"Nakamoto\",\n    \"knows\": [\n        {\n            \"@type\": \"Person\",\n            \"id\": \"gavinandresen.id\"\n        }\n    ]\n}\n```\n\n## Overview\n\n### Usernames\n\nA blockchain ID = a name + a profile, registered on a blockchain.\n\nLet's say you register the username 'alice' within the 'id' namespace, the default namespace for usernames. Then your username would be expressed as `alice.id`.\n\n### Profiles\n\nProfile schema is taken from schema.org. The schema for a person record can be found at http://schema.org/Person. There are some fields that have yet to be included, like the \"account\", \"key\", \"policy\", \"id\", and \"publicKey\" fields. An updated schema definition will be published to a different location that superclasses the schema.org Person definition and adds these fields.\n\n#### Example Profile\n\n```json\n{\n    \"name\": \"Naval Ravikant\",\n    \"accounts\": []\n}\n```\n\n[<img src=\"/docs/buttons/button-profile.png\" width=\"200\">](/docs/Person/profile.md)\n\n### Profile Storage\n\nBlockchain ID profiles are stored in two files: a token file and a zone file:\n\n+ **token file** - contains signed tokens with profile data\n+ **zone file** - describes where to find the token file\n\n### Lookups\n\nAn identity lookup is performed as follows:\n\n1. lookup the name in blockstore's name records and get back the data hash associated with the name\n2. lookup the data hash in the blockstore DHT and get back the zone file\n3. scan the zone file for \"zone origin\" records and get the URL found in the \"data\" field - the token file URL\n4. issue a request to the token file URL and get back the token file\n5. parse through the token file for tokens and verify that all the tokens have valid signatures and that they can be tied back to the user's name (by using the public keychain)\n6. grab all of the claims in the tokens and merge them into a single JSON object, which is the user's profile\n\n### Zone Files\n\nA zone file contains an origin (the name registered), a TTL (not yet supported), and a list of records.\n\nEach record has a name, class, type, data, and checksums.\n\nIf the value of the \"name\" field is \"@\", that means the record corresponds to the \"zone origin\" of the name.\n\nThe \"class\" field corresponds to the namespace of the record's information. In ICANN DNS, this is traditionally \"IN\" for Internet, but this field could be changed to something else to indicate that the names are registered in a parallel DNS universe.\n\nThe \"type\" field indicates how the record should be resolved. Only \"CNAME\" is currently supported. This means that the name record should be interpreted as an alias of the URL that is provided in the \"data\" field.\n\nThe \"data\" field is interpretted in different ways, depending on the value in the \"type\" field. As mentioned previously, though, the only supported type at the moment is \"CNAME\", so the \"data\" field will contain a URL until that changes.\n\nThe \"checksums\" field indicates values in the parsed profile that should be considered \"immutable\" fields. One can be certain that the values of these fields cannot change because the values of their hashes must correspond to the corresponding values in the checksum records.\n\nThe \"publicKeychain\" field indicates the keychain that was used to sign the tokens found in the token file.\n\n#### Example Zone File\n\n```json\n{\n    \"origin\": \"alice.id\",\n    \"ttl\": \"1h\",\n    \"records\": [\n    ]\n}\n```\n\n[<img src=\"/docs/buttons/button-zone-file.png\" width=\"200\">](/docs/Person/zone-file.md)\n\n### Token Files\n\nThe token file contains a list of token records.\n\nEach record contains the encoded token, a \"data\" field with the decoded token, a \"chainPath\" that indicates how to get from the master public keychain to the signing public key, and an \"encrypted\" field that indicates whether or not the token is encrypted.\n\nTo validate each identity token, first decode the token and grab the public key of the issuer. Then, verify the token's signature with the public key. Then check to make sure you can derive the public key from the master public keychain using the chain path. If these checks pass, the token is valid.\n\nEach token in the token file has a header, a payload, and a signature. The payload is the important part. Each payload contains a \"claim\", a \"subject\", and an \"issuer\". The claim is the signed bit of information that goes into the construction of the profile. The subject references the identity that the claim is about. The issuer is the identity that is signing the token (and thus making a claim about the subject).\n\nIn the case of self-attested profile information, the subject and the issuer are the same person (one is making a statement about one's self).\n\nHowever, this can be extended to any statement made by any issuer about any other subject. For example, you can sign a statement attesting to your own birth date, and then your state DMV or bank can sign a statement making the same attestation about your birth date. Then, you can present those two signed statements to any other party and present proof of your birth date.\n\nThe cool part is that the identities referenced are public keys, not usernames. That means that you can present signed tokens to a party that show proof of your birth date, all without revealing your username and thus your identity. This process is known as selective disclosure of identity information.\n\n#### Example Token File\n\n```json\n[\n    {\n        \"token\": \"eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NiJ9.eyJjbGFpbSI6eyJuYW1lIjoiUnlhbiBTaGVhIiwiZ2l2ZW5OYW1lIjoiUnlhbiIsImZhbWlseU5hbWUiOiJTaGVhIn0sInN1YmplY3QiOnsiQHR5cGUiOiJQZXJzb24iLCJwdWJsaWNLZXkiOiIwM2QzOWI2YzM5NzEwOWFmYTNhZTE4NDRiMjEzMjE1NmE0YmYyMzYxN2ZlOTEzMmYwZmFjYzM4Y2NmOTQ1MmVhODYifSwiaXNzdWVyIjp7IkB0eXBlIjoiUGVyc29uIiwicHVibGljS2V5IjoiMDNkMzliNmMzOTcxMDlhZmEzYWUxODQ0YjIxMzIxNTZhNGJmMjM2MTdmZTkxMzJmMGZhY2MzOGNjZjk0NTJlYTg2In19.Wqo7GlyisTMRm7xQz98XBp4y_QDTTEQwhtnnoBxsXODupYJlj758rMQEFom2mU5p-WzJwWY8leHgWhoyKa4mXA\",\n        \"data\": {\n        },\n        \"chainPath\": \"9eace0988a7583d45c99ea0058b2687282ebbe4a2862c86aa0e2ed576cd1b49f\",\n        \"encrypted\": false\n    },\n]\n```\n\n[<img src=\"/docs/buttons/button-token-file.png\" width=\"200\">](/docs/Person/token-file.md)\n\n","blockstore":"# Blockstore\n\nThis page provides an overview of how to use each Blockstore command to control names and namespaces.  You will need to have installed [blockstore-client](https://github.com/blockstack/blockstore-client), and have access to a running Blockstore node.\n\n## Obtaining Names\n\nRegistering a new name is a two-step process:  it must first be *preordered*, and then *registered.*  Only the principal who preordered the name can register it.  This is done as an anti-squatting measure, in order to stop someone from stealing a name while it is being propagated through the network.\n\nA name owner can have multiple names.  The current limit is 25 per key pair, but this is arbitrary.\n\nEach name in Blockstore is part of a *namespace*.  The name identifies the namespace it belongs to by ending in \".<namespace ID>\".  For example, the name `swiftonsecurity.id` belongs to the `id` namespace.\n\nIn order to register a name, the namespace must exist and be open to name registration.  You can confirm this with the `get_namespace_blockchain_record` command, as follows:\n\n```\n$ blockstore-cli get_namespace_blockchain_record <namespace ID>\n```\n\nThis command will succeed only if the namespace is ready.  More details on namespaces can be found in the **Namespaces** section.\n\n**Name Preorders**\n\nTo preorder a name, a name owner needs *two* sets of key pairs:  one to preorder, and one to register.  The *second* key pair should be brand-new and known only to the name owner.  The second key pair's address does not need any Bitcoin, but the name owner will need to transfer some to it once it is necessary to update the name's profile.  The secrecy of the second key pair is important, because Blockstore uses its address as a cryptographic hash salt to blind would-be name squatters.  Once registered, the name will be controlled by the *second* key pair.\n\nThe name owner pays for the name by preordering it using the *first* key pair, since only the name owner will be able to claim it.  The amount paid can be determined with the `get_name_cost` command:\n\n***Example***\n\n```\n$ ./blockstore-cli get_name_cost swiftonsecurity.id\n[\n    {\n        \"satoshis\": 25000\n    }\n]\n```\n\nThe fee will be sent from the address of the private key used to preorder the name.\n\nOnce the name owner has found a suitably-priced name, the `preorder` command can be used to preorder it.  It is used as follows:\n\n```\n$ blockstore-cli preorder <name.namespace> <preorder_privatekey> <register_address>\n```\n\nOnce preordered, the name owner must register the name within 144 blocks of the preorder (about 24 hours).\n\n***Example***\n\nThe following command will preorder the name `swiftonsecurity.id`, granting control of the name to the private key tied to the `register_address` (the 3rd argument).\n\n```\n$ blockstore-cli preorder swiftonsecurity.id 5KMKzs7grgyatKURCgxB7SgdeYu35poaEumJShLxPpLTBCrpy8o 199VaCaC9p95otia9e2EH7i6yZq7EWJHk2\n```\n\nNote that the address of `5KMKzs7grgyatKURCgxB7SgdeYu35poaEumJShLxPpLTBCrpy8o` is `1HYWB9R8ZKXVfEUstJAPhdkJ3nRpc2KHCM`, while the private key of address `199VaCaC9p95otia9e2EH7i6yZq7EWJHk2` is actually `5JZAZzZo5JvCEc4x9pkNAdkLf468H4KVMMhrwcv6WKFJ9x3ZC7m`.  Address `1HYWB9R8ZKXVfEUstJAPhdkJ3nRpc2KHCM` will be charged 25000 satoshis (sent to the burn address `1111111111111111111114oLvT2`), plus mining fees and dust fees.\n\nThe result of the command will contain the transaction ID in Bitcoin, which the name owner can monitor to ensure that the rest of the Bitcoin network accepts the preorder transaction.  We advise the name owner to wait for six confirmations before the registering the name.\n\n**Name Registration**\n\nThe name owner should wait for at least six transaction confirmations to ensure that the preorder was accepted.  Once it has been accepted, the name owner must use the preorder key pair to register the name, and reveal the address of the new public key that will control it.\n\nThis is achieved with the `register` command:\n\n```\n$ blockstore-cli register <name.namespace> <preorder_privatekey> <register_address> \n```\n\nThis will create an empty profile for the name owner, and reveal to the world the name owner's new name, Bitcoin address, and preorder public key.\n\n***Example***\n\nTo register the preordered name `swiftonsecurity.id`, the name owner would run the following command:\n\n```\n$ blockstore-cli register swiftonsecurity.id 5KMKzs7grgyatKURCgxB7SgdeYu35poaEumJShLxPpLTBCrpy8o 199VaCaC9p95otia9e2EH7i6yZq7EWJHk2\n```\n\nThe result of the command will contain the transaction ID in Bitcoin, which the name owner can monitor to ensure that the rest of the network accepts the register transaction.  The cost of registering is simply the cost of the mining fee and dust fees for each output.\n\n## Reading and Writing Name Profiles\n\nBecause Blockstore is a name-centric storage system, every piece of data it stores is tied to an existing name.  This section describes how to interact with Blockstore name data.\n\nAll of the following examples use the [Blockstore command-line client](https://github.com/blockstack/blockstore-client).  Please see its [wiki](https://github.com/blockstack/blockstore-client/wiki) to install it.\n\n**Looking up Names**\n\nMost of a name's associated data is stored on an external DHT run by Blockstore peers.  Only a few records are stored on the blockchain itself (Figure 1).  Blockstore provides methods for fetching either just the information from the blockchain (the `get_name_blockchain_record` command), or the name owner's profile data stored in the DHT (the `lookup` command).\n\n<img src=\"https://s3.amazonaws.com/onenameblog/openname-bitcoin-dht-diagram-4.png\" width=\"650\"/>\n\n*Figure 1: An overview of how blockchain records in Blockstore point to name profile data in the DHT*\n\nLooking up the blockchain-hosted data for a name is done with the `get_name_blockchain_record` command.  This command fetches data stored in the Blockstore daemon itself, including the key in the DHT that refers to the name's profile data.  It is used as follows:\n\n```\n$ blockstore-cli get_name_blockchain_record <name>\n```\n\n***Example***\n\nThe following command will return the information Blockstore found from the blockchain for the name `judecn.id`:\n\n```\n$ blockstore-cli get_name_blockchain_record judecn.id\n{\n    \"address\": \"16EMaNw3pkn3v6f2BgnSSs53zAKH4Q8YJg\",\n    \"block_number\": 373622,\n    \"first_registered\": 373622,\n    \"history\": {\n        \"373622\": [\n            {\n                \"address\": \"16firc3qZU97D1pWkyL6ZYwPX5UVnWc82V\",\n                \"fee\": 38500,\n                \"history_snapshot\": true,\n                \"importer\": \"76a9143e2b5fdd12db7580fb4d3434b31d4fe9124bd9f088ac\",\n                \"importer_address\": \"16firc3qZU97D1pWkyL6ZYwPX5UVnWc82V\",\n                \"name\": \"judecn.id\",\n                \"opcode\": \"NAME_IMPORT\",\n                \"recipient\": \"76a914caee018147f2d5ff32ca3b2ef35c17755bce440e88ac\",\n                \"recipient_address\": \"1KVzcgurJmTr4Cr44h6raEVtoGhm7ZZxzm\",\n                \"sender\": \"76a9143e2b5fdd12db7580fb4d3434b31d4fe9124bd9f088ac\",\n                \"sender_pubkey\": \"0411d88aa37a0eea476a5b63ca4b1cd392ded830865824c27dacef6bde9f9bc53fa13a0926533ef4d20397207e212c2086cbe13db5470fd29616abd35326d33090\",\n                \"txid\": \"c698ac4b4a61c90b2c93dababde867dea359f971e2efcf415c37c9a4d9c4f312\",\n                \"value_hash\": \"dbbdedc2b81d875403cc76486625a19f1e3b3c6f\",\n                \"vtxindex\": 63\n            }\n        ],\n        \"374075\": [\n            {\n                \"address\": \"1KVzcgurJmTr4Cr44h6raEVtoGhm7ZZxzm\",\n                \"importer\": \"76a9143e2b5fdd12db7580fb4d3434b31d4fe9124bd9f088ac\",\n                \"importer_address\": \"16firc3qZU97D1pWkyL6ZYwPX5UVnWc82V\",\n                \"sender\": \"76a914caee018147f2d5ff32ca3b2ef35c17755bce440e88ac\",\n                \"sender_pubkey\": \"0411d88aa37a0eea476a5b63ca4b1cd392ded830865824c27dacef6bde9f9bc53fa13a0926533ef4d20397207e212c2086cbe13db5470fd29616abd35326d33090\",\n                \"txid\": \"c698ac4b4a61c90b2c93dababde867dea359f971e2efcf415c37c9a4d9c4f312\",\n                \"value_hash\": \"dbbdedc2b81d875403cc76486625a19f1e3b3c6f\",\n                \"vtxindex\": \"63\"\n            }\n        ],\n        \"383270\": [\n            {\n                \"address\": \"1KVzcgurJmTr4Cr44h6raEVtoGhm7ZZxzm\",\n                \"importer\": \"76a9143e2b5fdd12db7580fb4d3434b31d4fe9124bd9f088ac\",\n                \"importer_address\": \"16firc3qZU97D1pWkyL6ZYwPX5UVnWc82V\",\n                \"sender\": \"76a914caee018147f2d5ff32ca3b2ef35c17755bce440e88ac\",\n                \"sender_pubkey\": \"0411d88aa37a0eea476a5b63ca4b1cd392ded830865824c27dacef6bde9f9bc53fa13a0926533ef4d20397207e212c2086cbe13db5470fd29616abd35326d33090\",\n                \"txid\": \"7cfdfcf0c0abac9641ed5e253e7ba2b3ddabbc0b15302a4fc138519dd028d3ea\",\n                \"value_hash\": \"dbbdedc2b81d875403cc76486625a19f1e3b3c6f\",\n                \"vtxindex\": 234\n            }\n        ]\n    },\n    \"importer\": \"76a9143e2b5fdd12db7580fb4d3434b31d4fe9124bd9f088ac\",\n    \"importer_address\": \"16firc3qZU97D1pWkyL6ZYwPX5UVnWc82V\",\n    \"last_renewed\": 373622,\n    \"name\": \"judecn.id\",\n    \"op\": \";\",\n    \"op_fee\": 100000.0,\n    \"opcode\": \"NAME_IMPORT\",\n    \"preorder_block_number\": 373622,\n    \"revoked\": false,\n    \"sender\": \"76a914395f3643cea07ec4eec73b4d9a973dcce56b9bf188ac\",\n    \"sender_pubkey\": \"0411d88aa37a0eea476a5b63ca4b1cd392ded830865824c27dacef6bde9f9bc53fa13a0926533ef4d20397207e212c2086cbe13db5470fd29616abd35326d33090\",\n    \"txid\": \"1510e1582f48c7ea1c57156e6ac5ae0d2c0960cfb4d17db0860e140f6900beed\",\n    \"value_hash\": \"dbbdedc2b81d875403cc76486625a19f1e3b3c6f\",\n    \"vtxindex\": 108\n}\n```\n\nThe above record contains the current set of information Blockstore extracted from the blockchain pertaining to name `judecn.id`. The individual fields are described as follows:\n\n* `address`: If given, this is the name's associated Bitcoin address.\n* `first_registered`:  This is the block number in which the name was registered.\n* `history`: This is the history of changes to this name, keyed by block number.\n* `importer`: This is the compiled script generated by the principal that imported this name into this namespace (only present for names that were imported instead of registered).\n* `importer_address`: This is the address of the principal that imported this name into this namespace (only present for names that were imported instead of registered).\n* `last_renewed`:  This is the block number in which the name was last renewed.\n* `op_fee`: This is the number of Satoshis spent on the last operation.\n* `opcode`: This is the last operation that occurred on this name.\n* `preorder_block_number`: This is the block at which this name was created.  For registered names, this is the block number of the associated preorder.  For imported names, this is the block number at which the name was imported.\n* `revoked`:  This indicates whether or not the name was revoked by its owner.\n* `sender`:  This is the hex-encoded Bitcoin script that was used to claim the name.  In this example, the script is a [pay-to-pubkey-hash](https://en.bitcoin.it/wiki/Transaction#Pay-to-PubkeyHash) script.\n* `sender_pubkey`:  If given, this is the name's associated Bitcoin public key.\n* `txid`: This is the transaction ID at which the last name operation occurred.\n* `value_hash`:  This is the hash of the name's associated profile information.  It is the key for the profile information in the DHT.\n* `vtxindex`: This is the numerical index within the block at which the transaction was discovered.\n\n\n**Getting a Name's Profile Data**\n\nLooking up the DHT-hosted data for a name is done with the `lookup` command.  This command fetches data from the DHT, using the `value_hash` field for the given name.  It is used as follows:\n\n```\n$ blockstore-cli lookup <name>\n```\n\nThis command returns all of the information used to construct the name's profile.  The data is pulled from the DHT, or from the storage provider(s) designated by `blockstore-cli`.  In particular, the following fields will be present, unless otherwise stated:\n\n* `address`: The base58-encoded hash of the name owner's public key (i.e. their Bitcoin address).\n* `creation`: This is a JSON object describing the consensus of the network at the time name's state was first detected by Blockstore.  It has the following fields:\n   * `consensus_hash`: This is the consensus hash for this name's import or preorder.  If the name was imported, the consensus hash comes from the namespace preorder transaction in the blockchain.  If the name was preordered, the consensus hash comes from the preorder transaction in the blockchain.\n   * `consensus_block_id`: This is the block number for the above consensus hash.\n   * `type`:  This is either \"NAME_PREORDER\" if the name was preordered, or \"NAME_IMPORT\" if the name was imported.  It indicates how to interpret the above consensus hash and block number.\n* `modified`: (OPTIONAL) This is a JSON object describing the consensus of the network at the time of this name's state was last altered by a NAME_UPDATE or NAME_TRANSFER.  It will have the following fields:\n   * `consensus_hash`: This is the consensus hash for this name's update or transfer.\n   * `consensus_block_id`: This is the block number for the above consensus hash.\n   * `type`:  This is either \"NAME_UPDATE\" if the name was updated, or \"NAME_TRANSFER\" if the name was transferred.  It indicates how to interpret the above consensus hash and block number.\n* `serial_number`: This is the globally-unique identifier for the name.\n* `zone_file`: This is the data associated with the name, fetched from the DHT.  The contents of this field are arbitrary, but it is usually a JSON document.\n\n***Example***\n\nThe following command will return the information in the Blockstore DHT for the name `judecn.id`.  The information is **guaranteed by the blockchain to be authentic** because it must have a hash that matches the `value_hash`, and the `value_hash` was signed by `judecn.id`'s private key and was propagated to the longest blockchain fork.  Note that `judecn.id` was imported, not preordered.\n\n```\n$ blockstore-cli lookup judecn.id\n{\n    \"address\": \"16EMaNw3pkn3v6f2BgnSSs53zAKH4Q8YJg\",\n    \"creation\": {\n        \"consensus_block_id\": 373600,\n        \"consensus_hash\": \"17ac43c1d8549c3181b200f1bf97eb7d\",\n        \"type\": \"NAME_IMPORT\"\n    },\n    \"serial_number\": \"373622-63\",\n    \"zone_file\": {\n        \"avatar\": {\n            \"url\": \"https://s3.amazonaws.com/kd4/judecn\"\n        },\n        \"bio\": \"PhD student\",\n        \"bitcoin\": {\n            \"address\": \"17zf596xPvV8Z8ThbWHZHYQZEURSwebsKE\"\n        },\n        \"cover\": {\n            \"url\": \"https://s3.amazonaws.com/97p/gQZ.jpg\"\n        },\n        \"facebook\": {\n            \"proof\": {\n                \"url\": \"https://facebook.com/sunspider/posts/674912239245011\"\n            },\n            \"username\": \"sunspider\"\n        },\n        \"github\": {\n            \"proof\": {\n                \"url\": \"https://gist.github.com/jcnelson/70c02f80f8d4b0b8fc15\"\n            },\n            \"username\": \"jcnelson\"\n        },\n        \"location\": {\n            \"formatted\": \"Princeton University\"\n        },\n        \"name\": {\n            \"formatted\": \"Jude Nelson\"\n        },\n        \"twitter\": {\n            \"proof\": {\n                \"url\": \"https://twitter.com/judecnelson/status/507374756291555328\"\n            },\n            \"username\": \"judecnelson\"\n        },\n        \"v\": \"0.2\",\n        \"website\": \"http://www.cs.princeton.edu/~jcnelson\"\n    }\n}\n```\n\n\n**Updating a Name's Profile**\n\nUpdating a profile from `blockstore-cli` is a matter of giving Blockstore the JSON document that represents the new profile information.  Blockstore will put the new profile hash into the blockchain, and upload the JSON document to the DHT and all other storage providers the `blockstore-cli` tool has been configured to use.\n\nBecause this operation writes data to the blockchain, the effect of the `update` will not become visible until six subsequent blocks have been mined.  The cost of the `update` operation is simply the cost of writing the requisite outputs to the blockchain as dust, plus mining fees.\n\nGiven the nature of this operation, the write to the blockchain must precede the write to the name owner's storage providers.  In the event that the write to the blockchain fails, no data will be uploaded to any storage providers.  In the event that the write to the blockchain succeeds (i.e. the transaction gets accepted) but the upload fails, the name owner can attempt to re-upload the JSON without issuing a new transaction by submitting the transaction ID along with the `update` command.  The transaction ID is used to prove to the storage providers that the write has been paid for by the writer.\n\nThe usage of this operation is as follows:\n\n```\n$ blockstore-cli update <name.namespace> <JSON string> <privatekey> [txid]\n```\n\n***Example***\n\nSuppose the owner of the name `swiftonsecurity.id` wanted to add a minimal profile, encoded as `{\"name\":{\"formatted\":\"Swift on Security\"},\"v\":\"2\"}`.  To do so, the command would be:\n\n```\n$ blockstore-cli update swiftonsecurity.id '{\"name\":{\"formatted\":\"Swift on Security\"},\"v\":\"2\"}' 5JZAZzZo5JvCEc4x9pkNAdkLf468H4KVMMhrwcv6WKFJ9x3ZC7m\n```\n\nNote that the private key used (`5JZAZzZo5JvCEc4x9pkNAdkLf468H4KVMMhrwcv6WKFJ9x3ZC7m`) has the address `199VaCaC9p95otia9e2EH7i6yZq7EWJHk2`, which is the registration address submitted for `swiftonsecurity.id` in the earlier registration example (not to be confused with the preorder key pair).\n\nNow, suppose that the update transaction succeeded as transaction ID `cd08dd0afff9838ede0b8f4e3a9ffbe95e1c81d7da1a38582b3ce93ad10f5e5a`, but uploading `{\"name\":{\"formatted\":\"Swift on Security\"},\"v\":\"2\"}` to the DHT failed.  The owner of `swiftonsecurity.id` can re-run the upload with:\n\n```\n$ blockstore-cli update swiftonsecurity.id '{\"name\":{\"formatted\":\"Swift on Security\"},\"v\":\"2\"}' 5JZAZzZo5JvCEc4x9pkNAdkLf468H4KVMMhrwcv6WKFJ9x3ZC7m cd08dd0afff9838ede0b8f4e3a9ffbe95e1c81d7da1a38582b3ce93ad10f5e5a\n```\n\n## Transferring and Revoking Names\n\nNames do not need to stay bound to the same owner indefinitely.  Instead, the name owner can opt to transfer it to a new owner.  The name owner can also opt to disable the name entirely by revoking it, thereby denying all future modifications to it until it expires.\n\n**Transferring Names**\n\nOnce a name has been registered, its owner can opt to transfer it to another address (i.e. another key pair).  This can be performed with the `transfer` command.\n\nThe name owner has the option of transferring the name's profile information along with the name.  If transferred, the profile content will be controllable only by recipient--the sender will be unable to update the data via Blockstore, and Blockstore will use the recipient's public key to authenticate data.  There are benefits and drawbacks to doing so depending on the circumstances, so we leave the choice to the users.  It is recommended to *not* transfer the profile information when transferring a name, since the recipient retains the option to rebuild the profile from the sender's profile at a later date.\n\nThe following command invocation will transfer a name, but not the profile data.  The third argument controls whether or not to transfer the profile.\n\n```\n$ blockstore-cli transfer <name.namespace> <recipient's Bitcoin address> False <name owner's private key>\n```\n\nThe following command invocation will transfer a name *and* the profile data.\n\n```\n$ blockstore-cli transfer <name.namespace> <recipient's Bitcoin address> True <name owner's private key>\n```\n\n***Example***\n\nThis command will transfer ownership of `swiftonsecurity.id` to the owner of the address `16firc3qZU97D1pWkyL6ZYwPX5UVnWc82V`:\n\n```\n$ blockstore-cli transfer swiftonsecurity.id 5JZAZzZo5JvCEc4x9pkNAdkLf468H4KVMMhrwcv6WKFJ9x3ZC7m 16firc3qZU97D1pWkyL6ZYwPX5UVnWc82V\n```\n\nNote that the private key `5JZAZzZo5JvCEc4x9pkNAdkLf468H4KVMMhrwcv6WKFJ9x3ZC7m` is the private key that owns the name, since its address (`199VaCaC9p95otia9e2EH7i6yZq7EWJHk2`) was the registration address in the earlier registration example (not to be confused with the preorder key pair).\n\n**Notes on Transferring Names**\n\nWe anticipate that a secondary market for existing names could form around this feature.  If so, we offer the following advice to buyers:\n\n* Check the revocation status of a name before buying.  If it is revoked, it is worthless.\n* Check that the name is not going to expire anytime soon--at least not for 30 blocks.  This is because the new owner should wait for at least six confirmations to transfer, and at least another six for the renewal fee to be processed.  The time between blocks is not guaranteed to be 10 minutes.\n* Use the `get_name_cost` command to learn the actual worth of the name.\n* Make sure the name's namespace is ready for registrations--it must show up with the `lookup_namespace` command.\n\n**Revoking Names**\n\nIf a name is no longer wanted, or the key pair that registered it was compromised, the name owner can revoke the name to disable any future transfers, updates, or renewals.  This is done with the `revoke` operation.\n\n**Revoking cannot be undone**.  The purposees of the `revoke` operation are to (1) deny an attacker the ability to alter any data associated with the name, and (2) announce to the world that all future data associated with this name is not authentic.\n\nBecause revoking a name involves writing to the blockchain, it has a cost, which is simply the cost of writing the requisite outputs to the blockchain as dust, plus mining fees.\n\nThe following command revokes a name:\n\n```\n$ blockstore-cli revoke <name.namespace> <name owner's private key>\n```\n\n***Example***\n\nTo revoke the name `swiftonsecurity.id`, the name owner would run:\n\n```\n$ blockstore-cli revoke swiftonsecurity.id 5JZAZzZo5JvCEc4x9pkNAdkLf468H4KVMMhrwcv6WKFJ9x3ZC7m\n```\n\nNote that the private key used has the address `199VaCaC9p95otia9e2EH7i6yZq7EWJHk2`, which is the registration address used in the earlier example (not to be confused with the preorder pair).\n\nA subsequent `lookup` will indicate that the name is revoked, since the `revoked` field will be set to `False`.\n\n## Renewing Names \n\nIn most namespaces, names have finite lifetimes and will eventually expire.  Exactly when is determined by the rules of the namespace, but a name is be said to have expired by a certain block number.  After this point, the name can be preordered and registered by someone else.  If the name owner wants to avoid this, the name must be *renewed*.\n\nWhen a name is renewed, its lifetime is reset to the maximum lifetime defined by the namespace.  Some namespaces allow names to have infinite lifetimes, in which case no renewal is necessary.\n\nThe fee to renew the name is determined by the rules of the namespace, but it is the same fee paid at registration.  The cost to renew can be obtained with the `get_name_cost` operation as before.\n\nThe following command invocation will renew a name:\n\n```\n$ blockstore-cli renew <name.namespace> <name owner's private key>\n```\n\n***Example***\n\nThis command will renew the name `swiftonsecurity.id`.  The owner of the address `199VaCaC9p95otia9e2EH7i6yZq7EWJHk2` will continue to own it for another 52595 blocks.\n\n```\n$ blockstore-cli renew swiftonsecurity.id 5JZAZzZo5JvCEc4x9pkNAdkLf468H4KVMMhrwcv6WKFJ9x3ZC7m\n```\n\nNote that the private key used has the address `199VaCaC9p95otia9e2EH7i6yZq7EWJHk2`, which is the registration address used in the earlier example (not to be confused with the preorder pair).\n\n## Namespaces \n\nBlockstore organizes names into namespaces.  A name's namespace can be identified by looking at the characters after the last '.' in the name.\n\n**Name Pricing**\n\nNamespaces exist to set fees and lifetimes for the sets of names they contain.  Namespace prices are characterized by orders of magnitude, determined by the namespace's creator.  To price names, each namespace defines a set of 16 price \"buckets\" that characterize the order of magnitude of the price of of 1-character names, 2-character names, etc., with the 16th bucket serving as a catch-all for names with at least 16 characters.  The absense of vowels and the presence of non-alpha characters add multiplicative discounts to the name's price.  The price is calculated as follows:\n\n* Let `B` be the namespace's \"base price\".\n* Let `K` be the namespace's constant price multiplier.\n* Let `L` be the length of the name.\n* Let `N[L-1]` be the bucket that the name falls into (i.e. the price's order of magnitude).\n* Let `V` be the discount for having no vowels (it is set to 1 for names with vowels).\n* Let `A` be the discount for having non-alphabet characters (it is set to 1 for names with only alphabetical characters).\n\nThen, the price of a name is calculated as `(K * (B ** N[L-1])) / (max([1, V, A]))`.  The units are in uBTC.\n\n***Example***\n\nThe pricing of the `id` namespace (specified in Bitcoin transaction `ab54b1c1dd5332dc86b24ca2f88b8ca0068485edf0c322416d104c5b84133a32`) is as follows:\n\n* K = 250 \n* B = 4 \n* N = [6, 5, 4, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n* V = 10\n* A = 10\n\nThen, the following prices hold:\n\n* The price of `a.id` is `(250 * (4**6)) / (max([1, 1, 1])) = 1024000 uBTC`, or 1.024 BTC.\n* The price of `1.id` is `(250 * (4**6)) / (max([1, 10, 10])) = 102400 uBTC`, or 0.1024 BTC.\n* The price of `abc.id` is `(250 * (4**4)) / (max([1, 1, 1])) = 64000 uBTC`, or 0.064 BTC.\n* The price of `bcd.id` is `(250 * (4**4)) / (max([1, 10, 1])) = 6400 uBTC`, or 0.0064 BTC.\n* The price of `judecn.id` is `(250 * (4**1)) / (max([1, 1, 1]) = 1000 uBTC`, or 0.001 BTC.\n* The price of `j00dcn.id` is `(250 * (4**1)) / (max([1, 10, 10]) = 100 uBTC`, or 0.0001 BTC.\n* The price of `swiftonsecurity.id` is `(250 * (4**0)) / min([1, 1, 1])` = 250 uBTC, or 0.00025 BTC.\n\n**Namespace Pricing**\n\nNamespaces are not free; their price is a function of their length.  Blockstore enforces the following pricing rules on creating namespaces:\n\nNamespace ID length | Cost (in BTC)\n------------------- | -------------:\n1                   | 400.0\n2, 3                | 40.0\n4, 5, 6, 7          | 4.0 \n8 and up            | 0.4\n\nNamespace creation fees are sent to the Blockstore burn address (`1111111111111111111114oLvT2`).  The price of a namespace can be queried with `blockstore-cli` via the `get_namespace_cost` command:\n\n```\n$ blockstore-cli get_namespace_cost <namespace ID>\n```\n\n**Creating a Namespace**\n\nCreating a namespace is a 4-step process:\n\n* Preordering a namespace\n* Revealing a namespace \n* Importing names into the namespace \n* Opening the namespace for registration\n\nBefore the namespace is open for registration, the namespace creator has the power to define the namespace ID, its pricing parameters, and add an initial set of names.  Once the namespace is opened for registration, anyone can create names within the namespace, subject to pricing and availability.\n\nJust as how Blockstore requires name owners to preorder and then register a name, it also requires namespace creators to preorder and then reveal namespaces.  Preordering a namespace requires the namespace creator to have two key pairs: one for preordering the namespace, and one for revealing it.  The reason for this is to stop a would-be namespace squatter from stealing the namespace as it is revealed--by design, the squatter cannot see the name of the namespace until after it has been preordered.  As such, it is important that the revealing key pair be *known only to the namespace creator*.\n\nThe command to pre-order a namespace is:\n\n```\n$ blockstore-cli namespace_preorder <namespace ID> <preorder private key> <reveal_address>\n```\n\n***Example***\n\nThe following command will preorder the namespace `abc`, granting control of the name to the private key tied to the `reveal_address` (the 3rd argument).\n\n```\n$ blockstore-cli namespace_preorder abc 5KMKzs7grgyatKURCgxB7SgdeYu35poaEumJShLxPpLTBCrpy8o 199VaCaC9p95otia9e2EH7i6yZq7EWJHk2\n```\n\nNote that the address of `5KMKzs7grgyatKURCgxB7SgdeYu35poaEumJShLxPpLTBCrpy8o` is `1HYWB9R8ZKXVfEUstJAPhdkJ3nRpc2KHCM`, while the private key of address `199VaCaC9p95otia9e2EH7i6yZq7EWJHk2` is actually `5JZAZzZo5JvCEc4x9pkNAdkLf468H4KVMMhrwcv6WKFJ9x3ZC7m`.  Address `1HYWB9R8ZKXVfEUstJAPhdkJ3nRpc2KHCM` will be charged 40 BTC (sent to the burn address `1111111111111111111114oLvT2`), plus mining fees and dust fees.\n\nThe result of the command will contain the transaction ID in Bitcoin, which the namespace creator can monitor to ensure that the rest of the Bitcoin network accepts the preorder transaction.  We advise the namespace creator to wait for six confirmations before the revealing the namespace.\n\n**Revealing a Namesace**\n\nOnce a namespace has been preordered, the creator (and only the creator) can reveal it.  In doing so, the creator sets the lifetime for each name in the namespace, as well as all of the pricing parameters (K, B, N, V, and A).\n\n**Caveat**: Once a namespace is revealed, its properties are set forever.\n\nThe command to do so is:\n\n```\n$ blockstore-cli namespace_reveal <namespace ID> <reveal_address> <lifetime_in_blocks> <K> <B> <N> <A> <V> <preorder private key>\n```\n\nThe cost of revealing a namespace is simply the mining fee plus the dust fees for each output.\n\n***Example***\n\nSuppose the namespace creator of `abc` wanted each name to cost at least 200 uBTC, and for name prices to vary by powers of 10.  Suppose that the desired pricing rule was that all names between lengths 1 and 10 would cost 20 BTC, and all names greater than length 8 would cost 2 BTC.  Suppose that names could receive a 50-fold discount if they had no vowels, and a 100-fold discount if they had numbers or punctuation.  Suppose also that names were supposed to expire after 3 years.  To reveal the namespace with these properties, the namespace creator would issue the command:\n\n```\n$ blockstore-cli namespace_reveal abc 199VaCaC9p95otia9e2EH7i6yZq7EWJHk2 157788 200 10 4,4,4,4,4,4,4,4,3,3,3,3,3,3,3,3 100 50 5KMKzs7grgyatKURCgxB7SgdeYu35poaEumJShLxPpLTBCrpy8o\n```\n\n**Importing Names**\n\nAfter the namespace is revealed, the namespace creator has the opportunity to populate the namespace with names.  In doing so, the creator registers the name for a particular address and assigns it the hash of its profile.  This way, when the namespace is ready for registration, the names are already owned by their respective owners.\n\nThe command to import a name is:\n\n```\n$ blockstore-cli name_import <name.namespace> <name owner's address> <name owner's profile hash> <name revealer private key>\n```\n\nThe fourth argument is the private key meant for revealing names, whose address was used as the revealer address when preordering and revealing the namespace.  This private key is *not* the one used to preorder and reveal the namespace.\n\nThe cost of importing names is just the cost of the mining fees, plus the dust cost for each output.  Importantly, the namespace creator does *not* pay the name's price when importing names.\n\n***Example***\n\nSuppose the creator of `abc` wanted to import the name `swiftonsecurity.abc`, and have it be owned by the owner of the address `199VaCaC9p95otia9e2EH7i6yZq7EWJHk2`.  Suppose the owner had a name profile with hash `8b3fe3a9ecb162cb7968d5a889fbf159c9f317cb`.  To import this name, the namespace creator would issue the command:\n\n```\n$ blockstore-cli name_import swiftonsecurity.abc 199VaCaC9p95otia9e2EH7i6yZq7EWJHk2 8b3fe3a9ecb162cb7968d5a889fbf159c9f317cb 5JZAZzZo5JvCEc4x9pkNAdkLf468H4KVMMhrwcv6WKFJ9x3ZC7m\n```\n\nThen, when the namespace is ready, only the owner of `199VaCaC9p95otia9e2EH7i6yZq7EWJHk2` will be able to update, transfer, or revoke the name `swiftonsecurity.abc`.\n\n**Notes on Importing Names**\n\n* A namespace must be ready no later than 52596 blocks after they are revealed.  Otherwise, it expires, as well as all of its imported names.  Namespace creators should calculate how long it will take to import all names *before* creating the namespace.\n* Sometimes, there can be a lot of names to reveal at once, and revealing them all in sequence can be prohibitively time-consuming.  To address this, Blockstore will accept name imports that have come from one of up to 300 unhardened hierarchical deterministic (HD/BIP32) key pairs derived from the name revealer private key.  Each key pair's wallet can be loaded with BTC, and each used to import a disjoint subset of names concurrently.\n* Sometimes, the namespace creator will need to update an already-imported name.  For example, the name owner might disagree with the namespace creator as to what the hash of the profile is.  To address this, Blockstore honors the *last-seen* copy of a name import whenever there is a conflict.  The namespace creator can overwrite old name imports this way until the namespace is declared ready.\n\n**Making the Namespace Ready**\n\nOnce the namespace creator is satisfied with the state of the namespace, it can be made ready for registration by the public.  Once this happens, the namespace creator will no longer have the power to alter the set of names in the namespace, except for the ones (s)he owns (and (s)he is limited to 25 names by the Blockstore implementation).\n\nIn order to make the namespace ready, the namespace creator issues the `namespace_ready` command:\n\n```\n$ blockstore-cli namespace_ready <namespace ID> <revealer private key>\n```\n\nNote that the private key is the *revealer* private key, not the preorder pirvate key.\n\nOnce accepted and recognized by Blockstore, the namespace will be open for registration--anyone will be able to preorder and register currently-unclaimed names.\n\nThe cost of making a namespace ready is simply the mining fee plus the dust cost of each output.\n\n***Example***\n\nTo make the namespace `abc` ready, the namespace creator would run:\n\n```\n$ blockstore-cli namespace_ready abc 5JZAZzZo5JvCEc4x9pkNAdkLf468H4KVMMhrwcv6WKFJ9x3ZC7m\n```\n","index":"# Blockstack Docs\n\nHere you'll find documentation on everything from blockstore to blockchain ID to blockchain auth."}