{"bootstrapping":"# Bootstrapping\n\nA full Blockstore peer not only stores each name and namespace it finds while processing the blockchain, but also the history of operations on it.  In particular, Blockstore records each name and namespace's change history, so that a client can query a name or namespace _as it was at a prior blockchain height_.  For example, suppose Alice preordered `alice.id` at block 400000, registered it at block 400010, updated it twice in block 400020, and transferred it to Bob at block 400030.  Then, Charlie can query a Blockstore node for the state of the name `alice.id` as it was at block 400011, and see that it was registered to Alice.  At block 400009, he would see that it was still preordered.  He can query it at block 400025 and see that Alice had updated the name (he would see the effect of the second update).  He can also query the name at block 400031 and see that it was transferred to his public key.\n\nAs part of storing each name and namespace's history, Blockstore can determine at which block heights a record was changed.  For example, Charlie can query the change history for `alice.id`, and get back the list `[400000, 400010, 400020, 400030]`.\n\nBecause a name or namespace can be affected by multiple transactions within a single block, Blockstore additionally keeps track of the transaction-level ordering of a name's history.  For example, Charlie can query the number of times the record for `alice.id` changed in block 400020, and would be informed that it changed twice (because Alice sent two update-transactions).  If he queried the state of `alice.id` at block 400020, Blockstore would give him two versions of `alice.id`:  `alice.id` as it was when it was registered but not updated, and `alice.id` as it was when it was updated for the first time.\n\nThese three features--querying a record's past states, querying the block heights where a record changed, and querying how often it changed in a block--allow Blockstore to use a trusted consensus hash to verify the authenticity of an untrusted Blockstore peer's database.  Once it has done so, it can use the database instead of having to re-create it by downloading the blockchain.\n\nTo see how it works, consider that each record has the following information:\n\n* the index into the block of the transaction that changed it ('`txindex`')\n* the list of block heights where it changed ('`history`')\n* for each block height in '`history`', a list of '`txindex`' values where the name changed.\n* for each '`txindex`' value at a given block height, the list of fields that were changed by the transaction ('`changeset`') \n* a record-specific method ('`rollback`') that takes a record's history, changeset, historical block height, and transaction index as arguments and returns the record as it was at that particular block height and transaction.  This is simply a matter of iteratively copying over the fields from '`changeset`' into the current state in order from present back to the past, historical timestamp (similar to how a version control system would roll a source file back to a particular commit).\n\nTo verify the authenticity of an untrusted database, the Blockstore peer executes the following algorithm (Figure 2).\n\n```\ninput:\n   trusted_consensus_hash:  the trusted consensus hash\n   h:  the height of the block with the trusted consensus hash\n   h0: the initial block height\n   db: the untrusted database, as a list of records\n\noutput:\n   if successful, True\n   if unsuccessful, False\n\nsubroutines:\n   CONSENSUS_HASH( recs, consensus_hash_list ):  calculate the canonical serializations of each record in recs, and then calculate the cryptographic hash over them as well as the given consensus hash list\n\nlet consensus_hashes = []\nfor each block i from h0 to h\n\n   let recs_i = [rec where i in rec.history for rec in db]\n   let block_i_recs = []\n   let block_i_consensus_hashes = []\n\n   sort recs_i on 'txindex'\n   for rec in recs_i\n      let txindexes = rec.history[i]\n      sort txindexes\n\n      for txi in txindexes:\n         let historic_rec = rec.rollback(rec.history, rec.changeset, i, txi)\n         block_i_recs = block_i_recs ++ [historic_rec]\n   \n   let j = i - 1\n   while j >= h0\n      block_i_consensus_hashes ++ [consensus_hashes[j]]\n      j = j / 2\n   \n   let ch = CONSENSUS_HASH( block_i_recs, block_i_consensus_hashes )\n   consensus_hashes = consensus_hashes ++ [ch]\n\nif consensus_hashes[h] == trusted_consensus_hash\n   print \"db is consistent with the trusted consensus hash\"\n   return True\n\nelse\n   print \"db is not consistent with the trusted consensus hash\"\n   return False \n```\n\n_Figure 2: The fast bootstrapping algorithm's pseudocode.  Blockstore executes this to verify the authenticity of another Blockstore peer's database.  If the authenticity can be verified, then the peer can bootstrap itself from the database, without having to download the blockchain and regenerate its own database from scratch_\n\nIn effect, the Blockstore peer translates the database back into the sequence of transactions the untrusted peer processed, and replays them to recalculate the final consensus hash.  If it matches the trusted consensus hash, then the database is trustworthy.","consensus-rules":"# Consensus Rules\n\n![Consensus hash construction overview](/images/docs/consensus-hash.png)\n\n_Figure 1: Overview of how a consensus hash is constructed from a block's transactions_\n\nA Blockstore peer broadcasts name operations by writing them as transactions on an underlying blockchain.  Peer Blockstore nodes discover them by reading the blockchain and replaying the operations sequentially.  In doing so, the blockchain serves as an append-only log of Blockstore name operations, which when replayed in sequence allow a Blockstore peer to determine the history of operations on each name and namespace.\n\nBlockstore generates a consensus hash in a deterministic way by hashing a block's sequence of name operations, as well as a logarithmic number of prior consensus hashes (Figure 1).  At block height `h`, the consensus hash is calculated by first hashing the canonical forms of each name operation in transaction order, and then hashing the prior consensus hashes for all blocks at heights `{h | h - 2^i && i > 0 && h - 2^i >= h0}` (where `h0` is the block height of the first-ever name operation).  Consensus hashes are processed in a deterministic order, such as in increasing order on `i`.  This way, two Blockstore peers at block `h` will calculate the same consensus hash (with very high probability) if and only if they observed the same sequence of name operations and the same sequence of prior consensus hashes.","data-storage":"# Data Storage\n\nStoring large amounts of data in the blockchain can lead to blockchain bloat, so we decided to use external datastores, e.g., a DHT, for data storage while storing only hashes of the data in the blockchain, yielding virtually unlimited storage. Currently, the default (external) datastore is a kademlia-based DHT which is seamlessly integrated with blockstored.\n\nTo associate data with the name, one issues an \"update\" operation by including a hash of the data and storing the data itself in the DHT.\n\n### Data storage comparison\n\n|Method|Bytes|\n|---|---|\n|nulldata in OP_RETURN output|40|\n|nulldata in multi-sig output|66|\n|namecoin operation|520|\n|hash in nulldata, full data in DHT|unlimited|\n\n### Control Plane vs. Data Plane \n\nWe believe that the design principle of separating the \"control plane\" from the \"data plane\" (recently, popularized by [OpenFlow](https://www.opennetworking.org/)) applies to blockchain-based datastores. We separate the problem of a) who is the owner of a name and can issue updates to a name-value pair from b) what is most efficient (speed/cost/reliability) way of delivering data to the end-user. For (a) it makes sense to use the blockchain and for (b) it doesn't.\n\nThe control plane, should include registration and update of name-value pairs. Given the secure nature of these operations, performing them on the blockchain makes sense. We need to establish, in a decentralized manner, who registered which name before others and who is the owner of which name and issue updates. \n\nThe data plane, is primarily used to deliver the actual data. Hash(value) is in the blockchain and the actual 'value' is stored externally. Since hash(value) is in the blockchain, the only type of attack possible on external storage is data unavailability attack. Anyone can independently confirm that they received the correct value by checking the hash(value) in the blockchain. We believe that standard data delivery optimizations like CDNs, geo-mirrors, keeping copies of data in large-memory servers (e.g., memcached) etc applies to our design.   \n\n### Multiple External Stores \n\nCurrently, we only have one external datastore for storing values -- the kademlia-based DHT. However, there can be many external datastores e.g., [IPFS](https://github.com/ipfs/ipfs), [Syndicate](https://github.com/jcnelson/syndicate) etc. In fact, any person or company can decide to run a mirror and add the mirror to a \"discovery service\". How exactly to build such a discovery service is currently an [open question](https://github.com/openname/blockstore/issues/84). Orgs/people can also choose to mirror/index only a particular namespace and they don't have to mirror all data on Blockstore. This helps with scalability by adding one-layer of hierarchy. Let's say there are *m* namespaces with *n* name-value pairs in each namespace. Instead of indexing O(m x n), you can index O(n) information and *n* for your namespace could be significantly small.","faq":"# FAQ\n\n### Why did you choose to build on top of Bitcoin?\n\nBitcoin is the blockchain with the most users, the largest market cap, the most amount of software available for it, and the highest amount of security (in terms of the cost of attack). It only makes sense to gravitate to the top blockchain among cryptocurrencies.\n\n### Are you open to building on other blockchains?\n\nYes! While we decided to follow our instincts and build our experimental KV store on the Bitcoin blockchain, we are and have been considering other options like alt-coins, sidechains, and even a Namecoin upgrade. If you have a suggestion and some detailed information about why it makes more sense, please open an issue and we'll discuss.\n\n### How is the Blockstore different from Namecoin?\n\nThis is different from Namecoin in a few fundamental ways:\n\n1. It uses the Bitcoin blockchain, which is the top blockchain. See above.\n2. Rather than store data directly in the Blockchain, this stores the data outside of the blockchain in a DHT. This reduces blockchain bloat and allows for more data to be conveniently stored.\n3. Each namespace has a different pricing scheme for names. That means you can use a namespace with expensive names in order to avoid squatting (ideal for domains), or you can use a namespace with names that cost almost nothing, in order to save money (ideal for non-fungible tokens like trading cards), or you can go for something in the middle (ideal for usernames).\n4. Fees paid to register names go to miners instead of being burned or essentially wasted. This incentivizes mining and increases the overall security of the network.\n\n### Is there a mechanism to store encrypted data?\n\nThere isn't any support for this in this repo. However, to store encrypted data, simply encrypt your file before submitting the data to the blockchain.\n\n### Can't someone just store huge files in the DHT?\n\nNo, we currently cap the size to 8kb. The DHT is not meant for storage of large files (e.g. pictures, videos, etc.) and is only intended for relatively small or moderately sized plaintext files.  Instead, we provide a [storage API](https://github.com/blockstack/blockstore/wiki/Data-Storage) in Blockstore to give users the ability to get, put, and delete large data from storage providers of their choosing.\n\n### Aren't DHTs vulnerable to sybil attacks?\n\nYes. Unfortunately like Bitcoin and other systems, sybil attacks are possible. There is no theoretical solution to sybil attacks, but we take certain practical steps to minimize the effects and risks of this. Also, keep in mind that the only type of attack possible on the DHT is the \"data unavailablity\" attack. Anyone can independently verify that they received the correct data by checking the hash of the data in the blockchain. \n\n### Can nodes just pop in and out and confuse the network?\n\nYes, with nodes entering and exiting a DHT (a process known as churn), the routing tables of the DHT can get affected. The DHT network will recover from this over time, so unless someone is actively attacking the DHT 24/7, occasional churn is going to be largely unnoticeable.\n\n### Is there any incentive to run a node?\n\nNot currently, no.  Only that anyone who turns on the DHT node feature in blockstored is also by default running a full DHT node. If you have any ideas about explicit incentives for running DHT nodes, feel free to reach out!\n\n### Is there a layer on top of the DHT that can make it simpler to grab the data?\n\nAnyone can create a cache of all the DHT data by using the index of the data from the blockchain. We plan on creating such caches (e.g., in memcached servers) and providing easy access to the data through an API. Remember that anyone can verify that the data they received is correct by checking the hash of the data in the blockchain (so you're not trusting the DHT or the cache server).\n\n### Can I build and host my own index/cache of the data in the DHT?\n\nAbsolutely! Anyone can. See above. \n\n### Is OP_RETURN the only way to embed the operation data in the blockchain?\n\nCurrently, yes. However, we recognize the potential to use multi-sig transaction outputs and standard pay-to-pubkey-hash transaction outputs. If you think it's a good idea to add these options, open an issue and we'll discuss it.\n\n### Why do I have to preorder a name before registering it?\n\nIf we didn't require a step before registration, someone could just see that you're broadcasting the registration of a particular name and race you to have their registration included in the next block. By separating the registration into two steps, we're able to support the pre-registration of an undisclosed name followed by the public confirmation of the registration of that name.\n\n### Isn't it essentially free for miners to register names?\n\nNo.  All registration fees, renewal fees, and namespace creation fees are sent to the burn address 1111111111111111111114oLvT2.\n\n### Is there support for names that don't ever expire?\n\nYes. Each namespace has it's own settings, so if you'd like to register names that don't expire, simply use a namespace that has a flag set for non-expiration.\n\n### If my I update my profile daily, my transaction costs will be high. Can I avoid this?\n\nThere are a few ways to avoid this. The first method is to put the somewhat consistent profile data in the main blob, then include a pointer to a JSON file that has the extended data. Profile explorers will read the data in the file as an extension of the main blob, so updating the file will let you update the profile data without issuing a new transaction and updating the hash associated with the name. You can learn more in the openname specifications repo.\n\n### Can a name be owned by a multi-sig address?\n\nAbsolutely. In this system, names are owned by scriptPubKeys, so all scriptPubKey types that Bitcoin supports are supported here.","fork-detection":"# Fork Detection\n\nDue to their decentralized nature, proof-of-work blockchains like Bitcoin's cannot not guarantee write stability.  At any given point in time, there can be multiple blockchain _forks_--different blockchains worked on by disjoint sets of peers that diverge at a particular block.  This can happen if there is a network partition between two or more sets of peers, or if two sets of peers discover a different block for the same height at about the same time (Figure 5).\n\nThe way blockchain peers resolve diverging forks is to always attempt to work on the blockchain with the highest proof-of-work (i.e. the fork that cost the most energy to produce), and to discard all other forks.  This means that if a blockchain peer submits a transaction, it is possible for the peer to witness the transaction get incorporated into a block, but then later discard the block if the block was later discovered to be on a fork.\n\n![Blockchain fork event timeline](/images/docs/blockchain-fork.png)\n\n_Figure 5:  Timeline of events when the blockchain encounters a fork.  The transaction tx2 gets incorporated into a block on a fork that is later discarded.  As a result, only tx1 will appear on the blockchain with the most proof-of-work._\n\nThe consequence for Blockstore is that name operations can get lost if they are incorporated onto a minority fork.  This will lead to a divergence in the Blockstore peers' consensus hashes, since some peers will process name operations on a minority fork while others will not.  This is particularly devistating to name registrars that broadcast many name operations in a small amount of time, because they stand to lose a large number of transactions.  The challenge is to provide a way to quickly and automatically detect and resolve consensus hash divergences due to blockchain forks, in order to minimize the amount of time required to recover and minimize the number of lost transactions.\n\nFortunately, if the current block height is `h`, then the probability that the block at height `h - k` is on a fork decreases exponentially as a function of `k`.  As a result, Blockstore can avoid most forks simply by processing blocks only if they are at least `k` blocks lower than the highest block in the blockchain.  However, this does not eliminate the threat of forks.\n\n![Blockchain fork detection and recovery](/images/docs/fork-recovery.png)\n\n_Figure 6:  Schematic of Blockstore peer and backup peer deployments.  When a Blockstore peer detects disagreement in its consensus hash (1), it queries back-up peers until it finds an agreeing consensus hash (2).  From there, it fetches a copy of the back-up peer's database (3) and catches itself up to block `h - k`.  Blockstore operators that process many name operations back up successfully-sent operations to an indepedent, durable database (in green), so they can be replayed if all Blockstore nodes diverge._\n\nThe solution to detecting forks is to configure a set of mutually-trusting Blockstore peers to fetch the blockchain from different sources, and configure the peers to check every time a new block is discovered to see if they all agree on the same consensus hash at height `h - k` (Figure 6).  If they do not, then a fork at least `k` blocks long has occurred, and each peer needs to check with the backups to see if it diverged.  If it diverged, then it needs to roll back its database to the block height where it diverged, and re-download the blockchain to re-converge on the correct consensus hash.\n\nTo faciliate recover, a Blockstore peer operator runs an additional set of private, back-up Blockstore peers that process blocks up to heights `h - k - 2^i`, for all positive integers `i` such that `h - k - 2^i >= h0`.  These peers are not meant to be publicly reachable, but instead curate prior states of all name and namespace records, and serve as recovery checkpoints for the public set of peers processing blocks at height `h - k`.  If a peer processing at height `h - k` detects that it could be on a fork, it works backwards from the consensus hash at found at height `h - k` to find a consensus hash at height `h - k - 2^i` where it still agrees with a back-up peer.  In particular, it checks each consensus hash down from `h - k` in a linear fashion, and selects the peer with the largest `h - k - 2^i` that has a consensus hash that agrees.  Once found, the peer fetches a copy of the back-up peer's database, authenticates it (if the back-up peer is not trusted), and then re-builds the database up to height `h - k` by downloading the missing blocks from the blockchain.\n\nThe distribution of block heights the back-up peers follow was chosen to balance the number of blocks a peer will need to re-download on recovery against the likelihood of having to recover from a fork of a particular length.  The number of blocks a peer must re-download on recovery from a fork at height `h - d` is minimized when there is a back-up peer with a database at `h - d`.  However, it is inefficient to run `h0 - h` back-up peers, and most forks are expected to resolve in less than `k` blocks (those that don't are much more likely to resolve at depth `d` than at `d+1`).  Selecting a power-of-2 distribution of back-up peer height intervals ensures that a recovering peer will not download more than twice the number of blocks than the minimum number required, while also ensuring that the number of necessary back-up peers grows logarithmically with the blockchain height.  In addition, the interval distribution places most back-up peers close to `h - k`, which we expect to cover nearly all of the fork recovery scenarios for forks greater than `k` blocks.\n\nIt must be noted that this fork detection and recovery protocol only guarantees that the set of Blockstore peers are on the same fork; it does not guarantee that they are always on the majority blockchain fork, since it is possible for every Blockstore peer and corresponding blockchain peer to be on a minority fork.  The distribution of Blockstore peers and the blockchain peers they communicate with must be kept diverse, in order to minimize the chance of this happenning.  To prepare for this scenario, the Blockstore peer operator (e.g. a registrar) should replicate each processed name operation, independent of Blockstore peers, so they can be re-submitted once the fork resolves and the Blockstore peers are recovered.","index":"# Blockstack\n\nBlockstack provides decentralized DNS for blockchain applications.\n","installation":"# Installation\n\nThis page is meant to walk you through installing and starting up Blockstore for the first time.\n\n**Requirements**\n\n- [x] Acccess to a bitcoin node with a full transaction index (i.e. txindex is\nenabled). You need to be able to connect to a specific bitcoin node that stores\neach transaction. Note: This is ​*not*​ the default behavior, the `txindex` option\nhas to be explicitly enabled in the node.  For example, `btcd.onename.com` has\nthis feature enabled.\n- [x] [Python 2.6 or higher](https://www.python.org/). (Python 3.x not supported)\n- [x] Python 2.x development headers (in most Linux distributions, this is usually the `python-dev` or `python-devel` package).\n- [x] [The Python distutils package](https://docs.python.org/2/distutils/) (Verify\nas it is not always installed with Python)\n- [x] [Python pip](https://pypi.python.org/pypi/pip)\n\n**Installing with pip**\n\nTo install Blockstore from the (Python Package Index)[https://pypi.python.org/pypi], you can use the following command:\n\n```\n$ pip install blockstore\n```\n\nThis will install Blockstore, and all of its dependencies.\n\n**Installing from Source**\n\nWe use distutils to package Blockstore, and provide a setup.py script to pull in additional dependencies.  The package is built with:\n\n```\n$ python setup.py build\n```\n\nTo install blockstored and all of its dependent packages, run:\n\n```\n$ sudo python setup.py install\n```\n\n**Running Blockstore for the First Time**\n\nWhen you run Blockstore for the first time, you will be prompted for some basic configuration information.  In particular, Blockstore will need to know how to connect to your bitcoin node, and how to connect to a Bitcoin API provider.  By default, Blockstore will connect to the Bitcoin node fleet that Onename maintains.\n\nConnecting to a bitcoin node is just a matter of supplying Blockstore with the server, port, and login information.  Blockstore will pull transactions and data from it to reconstruct the name database locally.  In particular, Blockstore prompts for:\n\n* `user`: the bitcoin's RPC username (akin to `-rpcuser` in bitcoin-cli).  It defaults to `openname`.\n* `passwd`: the bitcoin's RPC password (akin to `-rpcpassword` in bitcoin-cli).  It defaults to `opennamesystem`.\n* `server`: the name or IP address of the bitcoin node (akin to `-rpcconnect` in bitcoin-cli).  It defaults to `btcd.onename.com`.\n* `port`: the RPC port number of the bitcoin node (akin to `-rpcport` in bitcoin-cli).  It defaults to `8332`.\n* `use_https`: whether or not to use SSL.  If you are unsure, type `True`.  It defaults to `True`.\n\nBlockstore needs to access [unspent outputs](https://bitcoin.org/en/glossary/unspent-transaction-output) (UTXOs) to create transactions. Bitcoind does not track UTXOs for all Bitcoin addresses, therefore blockstore needs access to a full UTXO index. Blockstore currently has the option to specify an API provider for accessing UTXOs and users don't need to deploy a UTXO index/database themselves. The API provider gets used to find unspent outputs and also for broadcasting transactions.  Blockstore comes with API support for:\n\n* [Blockcypher](http://www.blockcypher.com/)\n* [chain.com](http://chain.com)\n* [blockchain.info](https://blockchain.info)\n* A bitcoin node configured to track UTXOs\n\nYou will be prompted to select one of the four.  In the case of chain.com, Blockcypher, and blockchain.info, you will need to obtain an API token.  The details of how to go about doing so can be found at each of the websites above.  Blockchain.info and Blockcypher currently offer free API tokens.\n\nOnce you have chosen your API provider and have an API token, Blockstore will prompt you for them.  After you have entered all of the requisite information, Blockstore will save its configuration to `~/.blockstore/blockstore.ini` for future use.  \n\n***Example***\n\nBelow is an example trace of running `blockstored` for the first time.  The user selected the default options for connecting to the Bitcoin network, and selected Chain.com as the API provider.  The API token is redacted.\n\n```\n$ ./blockstored start\n--------------------------------------------------------\nBlockstore does not have enough information to connect\nto bitcoind.  Please supply the following parameters, or\npress [ENTER] to select the default value.\n--------------------------------------------------------\npasswd (default: 'opennamesystem'): \nport (default: '8332'): \nuser (default: 'openname'): \nuse_https (default: 'True'): \nserver (default: 'btcd.onename.com'): \n--------------------------------------------------------\nNOTE: Blockstore currently requires an external API\nfor querying unspent transaction outputs.  The set of\nsupported providers are:\nchain_com       \nblockcypher     \nblockchain_info \nbitcoind_utxo\nPlease get the requisite API tokens and enter them here.\n--------------------------------------------------------\nutxo_provider: chain_com\n-----------------------------------------------\nPlease enter your chain.com API key and secret.\n-----------------------------------------------\napi_key_id: *********\napi_key_secret: ********\n```\n\n**Administrating Blockstore**\n\nOnce you have configured blockstore, you will subsequently be able to start it with:\n\n```\n$ blockstored start \n```\n\nTo stop blockstore, simply run:\n\n```\n$ blockstored stop\n```\n\nBy default, blockstore will synchronize its database with the blockchain, and then become a daemon and serve RPC requests in the background.  If you want it to run in the foreground, simply pass `--foreground` with the `start` option (example: `blockstored start --foreground`).  By default, blockstore will log RPC requests to `~/.blockstore/blockstore.log.access` and blockchain indexing debug messages to `~/.blockstore/blockstore.log.indexer`.","light-nodes":"# Light Nodes\n\nThe set of back-links from a given block `h` to all blocks `h - 2^i` constitute a _Merkle skip-list_ (Figure 2).  Given the consensus hash at height `h`, a client can use an untrusted Blockstore peer to determine the name operations at any prior block using a logarithmic number of queries relative to blocks, and downloading a logarithmic number of bytes relative to the blockchain's size.  The process of verifying the authenticity of a prior name operation with a later known-good consensus hash is caled _Simplified Name Verification_ (SNV).\n\n![SNV protocol overview](/images/docs/snv-overview.png)\n\n_Figure 3: Overview of Simplified Name Verification (SNV) protocol.  Each row represents the blockchain, in decreasing block height order from left to right (h > h0).  The user wishes to verify the authenticity of a name operation in the block marked with a `?`.  In each step, the user trusts the consensus hash for the white outlined block, and uses it to verify the authenticity of that block's name operations, as well as the set of prior consensus hashes (belonging to yellow blocks indicated by the arrows).  By iteratively fetching name operations and consensus hashes for prior blocks, the user will eventually prove the authenticity of all name operations in the `?` block._\n\nTo see how this works, suppose that a user trusts the consensus hash at height `h`, but needs to verify a name operation in block `h - 11`.  Suppose that the blockchain currently has 17 blocks beyond height `h0` (Figure 2).  To do so, the user queries any Blockstore node to obtain all of the name operations processed at height `h`, and the consensus hashes for blocks `h - 1`, `h - 2`, `h - 4`, `h - 8`, and `h - 16`.  Once obtained, the user serializes the name operations and prior consensus hashes to re-calculate the consensus hash at `h`.  If the trusted consensus hash matches, then the user knows that both the name operations the prior consensus hashes are authentic.  The user then iteratively downloads name operations and consensus hashes in this way, until block `h - 11` is reached.  Then, the user will have obtained and verified the authenticity of all name operations in that block, including the desired name operation.\n\nA full trace of the algorithm's execution follows:\n\n* Let `CH(h)` be the consensus hash at block height `h`.\n* Let `HISTORIC_RECORDS(h)` be a subroutine that queries all records affected by transactions in the block at height `h`.  The returned records are in the historic state they were in at height `h` (see the \"Fast Bootstrapping\" section for details).\n\nFigure 3, step (1):\n\n1.  Fetch `HISTORIC_RECORDS(h)`, `CH(h-1)`, `CH(h-2)`, `CH(h-4)`, `CH(h-8)`, and `CH(h-16)`.\n2.  Serialize and hash `HISTORIC_RECORDS(h)`, `CH(h-1)`, `CH(h-2)`, `CH(h-4)`, `CH(h-8)`, and `CH(h-16)` and verify equal to `CH(h)`.  If not, abort.\n3.  `CH(h-8)` is now trusted, and is the closest consensus hash to block `h - 11`.\n\nFigure 3, step (2):\n\n4.  Fetch `HISTORIC_RECORDS(h-8)`, `CH((h-8)-1)`, `CH((h-8)-2)`, `CH((h-8)-4)`, and `CH((h-8)-8)`.\n5.  Serialize and hash `HISTORIC_RECORDS(h-8)`, `CH((h-8)-1)`, `CH((h-8)-2)`, `CH((h-8)-4)`, and `CH((h-8)-8)` and verify equal to `CH(h-8)`.  If not, abort.\n6.  `CH(h-8-2)` is now trusted, and is the closest consensus hash to block `h - 11`.\n\nFigure 3, step (3):\n\n7.  Fetch `HISTORIC_RECORDS(h-8-2)`, `CH((h-8-2)-1)`, `CH((h-8-2)-2)`, and `CH((h-8-2)-4)`.\n8.  Serialize and hash `HISTORIC_RECORDS((h-8)-2)`, `CH((h-8-2)-1)`, `CH((h-8-2)-2)`, and `CH((h-8-2)-4)` and verify equal to `CH(h-8-2)`.  If not, abort.\nM9.  `CH(h-8-2-1)` is now trusted, and is the consensus hash of the block with the name operations to verify.\n\nFigure 3, step (4):\n\n10.  Fetch `HISTORIC_RECORDS(h-8-2-1)`, `CH((h-8-2-1)-1)`, `CH((h-8-2-1)-2)`, and `CH((h-8-2-1)-4)`\n11.  Serialize and hash `HISTORIC_RECORDS(h-8-2-1)`, `CH((h-8-2-1)-1)`, `CH((h-8-2-1)-2)`, and `CH((h-8-2-1)-4)` and verify equal to `CH(h-8-2-1)`.  If not, abort.\n12.  `HISTORIC_RECORDS(h-8-2-1)` is now trusted.  Return the queried record as it was at block `h - 11`.\n\nExtrapolating, the general SNV algorithm works as follows (Figure 4).\n\n```\ninput:\n   trusted_consensus_hash:  the trusted consensus hash \n   h:  the height of the block with the trusted consensus hash \n   rec_id:  the name or namespace ID to query\n   h_rec:  the height of the record to query (must be less than h)\n   h0:  the height of the block with the first-ever Blockstore operation\n\noutput:\n   if successful, the queried record as it was at height h_rec\n   if unsuccessful, False\n\nsubroutines:\n   HISTORIC_RECORDS(h):  query to Blockstore that finds all records affected by transactions at height h, restores them to their state at height h, and returns them\n   CH(h):  query to Blockstore that returns the consensus hash at height h\n   CONSENSUS_HASH( recs, consensus_hash_list ):  calculates the consensus hash from a list of records and prior consensus hashes\n\nlet current_h = h\ntrusted_consensus_hash_table = {\n   h: trusted_consensus_hash\n}\n\nwhile current_h >= h_rec\n   let historic_recs = HISTORIC_RECORDS(current_h)\n   let current_consensus_hashes = []\n   let i = 1\n\n   while current_h - 2^i >= h0\n      let ch = CH(current_h - 2^i)\n      current_consensus_hashes = current_consensus_hashes ++ [ch]\n      i = i + 1\n\n   let ch_at_h = CONSENSUS_HASH(historic_recs, current_consensus_hashes)\n   if ch_at_h != trusted_consensus_hash_table[current_h]\n      print \"Consensus hash mismatch at height \", ch_at_h\n      return False\n\n   if current_h == h_rec\n      break\n \n   else\n      let current_h = minimum([k for k in trusted_consensus_hash_table.keys where k >= h_rec])\n   \nprint \"Consensus hash matches\"\nfind rec in historic_recs where rec.rec_id == rec_id\nreturn rec\n```\n\n_Figure 4: The SNV algorithm pseudocode.  A Blockstore client executes this algorithm to use a known-good consensus hash to determine the prior state of a given record.  The client does not need to trust the Blockstore peer._","name-lookups":"# Name Lookups\n\nThis page describes how to look up information on a name.  You will need to have installed [blockstore-client](https://github.com/blockstack/blockstore-client), and have access to a full Blockstore node.\n\n### Getting a Name's Data\n\nUsers use Blockstore to securely associate data with their names.  The data itself is stored externally in a DHT, but the hash and some metadata is embedded in the underlying blockchain.  To fetch the *data*, the command format is as follows:\n\n```\n$ blockstore-cli lookup <name>\n```\n\nUpon successful execution, the command will print out a JSON object with the following fields:\n\n* `address`: the base58-encoded hash of the name owner's public key (i.e. their Bitcoin address).\n* `creation`: this is a JSON object with the following fields:\n   * `consensus_hash`: This is the consensus hash for this name's import or preorder.  If the name was imported, the consensus hash comes from the namespace preorder transaction in the blockchain.  If the name was preordered, the consensus hash comes from the preorder transaction in the blockchain.\n   * `consensus_block_id`: This is the block number for the above consensus hash.\n   * `type`:  This is either \"NAME_PREORDER\" if the name was preordered, or \"NAME_IMPORT\" if the name was imported.  It indicates how to interpret the above consensus hash and block number.\n* `serial_number`: this is the globally-unique identifier for the name.\n* `zone_file`: this is the data associated with the name, fetched from the DHT.  The contents of this field are arbitrary, but it is usually a JSON document.\n\nIf the name was since updated, it will also have a `modified` field in addition to the `creation` field.  The `modified` field contains the exact same structure, but with values reflecting the most recent update or transfer.\n\nOn error, the command will print out a JSON object with an `error` field.\n\n**Example**\n\nIn this example, we look up the data associated with the name `judecn.id`.  The associated data just happens to be a JSON document in this case, but the data can be anything at all in practice.\n\n```\n$ blockstore-cli lookup judecn.id         \n{\n    \"address\": \"16EMaNw3pkn3v6f2BgnSSs53zAKH4Q8YJg\",\n    \"creation\": {\n        \"consensus_block_id\": 373600,\n        \"consensus_hash\": \"17ac43c1d8549c3181b200f1bf97eb7d\",\n        \"type\": \"NAME_IMPORT\"\n    },\n    \"serial_number\": \"373622-63\",\n    \"zone_file\": {\n        \"avatar\": {\n            \"url\": \"https://s3.amazonaws.com/kd4/judecn\"\n        },\n        \"bio\": \"PhD student\",\n        \"bitcoin\": {\n            \"address\": \"17zf596xPvV8Z8ThbWHZHYQZEURSwebsKE\"\n        },\n        \"cover\": {\n            \"url\": \"https://s3.amazonaws.com/97p/gQZ.jpg\"\n        },\n        \"facebook\": {\n            \"proof\": {\n                \"url\": \"https://facebook.com/sunspider/posts/674912239245011\"\n            },\n            \"username\": \"sunspider\"\n        },\n        \"github\": {\n            \"proof\": {\n                \"url\": \"https://gist.github.com/jcnelson/70c02f80f8d4b0b8fc15\"\n            },\n            \"username\": \"jcnelson\"\n        },\n        \"location\": {\n            \"formatted\": \"Princeton University\"\n        },\n        \"name\": {\n            \"formatted\": \"Jude Nelson\"\n        },\n        \"twitter\": {\n            \"proof\": {\n                \"url\": \"https://twitter.com/judecnelson/status/507374756291555328\"\n            },\n            \"username\": \"judecnelson\"\n        },\n        \"v\": \"0.2\",\n        \"website\": \"http://www.cs.princeton.edu/~jcnelson\"\n    }\n}\n```\n\nHere is an example of a lookup on a user that does not exist:\n\n```\n$ blockstore-cli lookup nonexistent.id\n{\n    \"error\": \"Not found.\"\n}\n```\n\n### Getting a Name's Metadata\n\nThe blockchain itself stores some metadata for each name, which Blockstore tracks separately.  The metadata includes information such as a name's update history, the locations in the blockchain at which the name was altered, and so on.  The command format is as follows:\n\n```\n$ blockstore-cli get_name_blockchain_record <name>\n```\n\nOn success, the command prints out a JSON object that contains all the information Blockstore learned about this name from the underlying blockchain.  See the \"Reading and Writing Name Profiles\" section in the [Usage](https://github.com/blockstack/blockstore/wiki/Usage) document for an overview of what each of the fields mean.\n\nIf this command fails, it prints out a JSON object with an `error` key, as well as an associated error message.\n\n**Example**\n\nIn this example, we look up the blockchain metadata for the name `judecn.id`\n\n```\n$ blockstore-cli get_name_blockchain_record judecn.id\n{\n    \"address\": \"16EMaNw3pkn3v6f2BgnSSs53zAKH4Q8YJg\",\n    \"block_number\": 373622,\n    \"first_registered\": 373622,\n    \"history\": {\n        \"373622\": [\n            {\n                \"address\": \"16firc3qZU97D1pWkyL6ZYwPX5UVnWc82V\",\n                \"fee\": 38500,\n                \"history_snapshot\": true,\n                \"importer\": \"76a9143e2b5fdd12db7580fb4d3434b31d4fe9124bd9f088ac\",\n                \"importer_address\": \"16firc3qZU97D1pWkyL6ZYwPX5UVnWc82V\",\n                \"name\": \"judecn.id\",\n                \"opcode\": \"NAME_IMPORT\",\n                \"recipient\": \"76a914caee018147f2d5ff32ca3b2ef35c17755bce440e88ac\",\n                \"recipient_address\": \"1KVzcgurJmTr4Cr44h6raEVtoGhm7ZZxzm\",\n                \"sender\": \"76a9143e2b5fdd12db7580fb4d3434b31d4fe9124bd9f088ac\",\n                \"sender_pubkey\": \"0411d88aa37a0eea476a5b63ca4b1cd392ded830865824c27dacef6bde9f9bc53fa13a0926533ef4d20397207e212c2086cbe13db5470fd29616abd35326d33090\",\n                \"txid\": \"c698ac4b4a61c90b2c93dababde867dea359f971e2efcf415c37c9a4d9c4f312\",\n                \"value_hash\": \"dbbdedc2b81d875403cc76486625a19f1e3b3c6f\",\n                \"vtxindex\": 63\n            }\n        ],\n        \"374075\": [\n            {\n                \"address\": \"1KVzcgurJmTr4Cr44h6raEVtoGhm7ZZxzm\",\n                \"importer\": \"76a9143e2b5fdd12db7580fb4d3434b31d4fe9124bd9f088ac\",\n                \"importer_address\": \"16firc3qZU97D1pWkyL6ZYwPX5UVnWc82V\",\n                \"sender\": \"76a914caee018147f2d5ff32ca3b2ef35c17755bce440e88ac\",\n                \"sender_pubkey\": \"0411d88aa37a0eea476a5b63ca4b1cd392ded830865824c27dacef6bde9f9bc53fa13a0926533ef4d20397207e212c2086cbe13db5470fd29616abd35326d33090\",\n                \"txid\": \"c698ac4b4a61c90b2c93dababde867dea359f971e2efcf415c37c9a4d9c4f312\",\n                \"value_hash\": \"dbbdedc2b81d875403cc76486625a19f1e3b3c6f\",\n                \"vtxindex\": \"63\"\n            }\n        ],\n        \"383270\": [\n            {\n                \"address\": \"1KVzcgurJmTr4Cr44h6raEVtoGhm7ZZxzm\",\n                \"importer\": \"76a9143e2b5fdd12db7580fb4d3434b31d4fe9124bd9f088ac\",\n                \"importer_address\": \"16firc3qZU97D1pWkyL6ZYwPX5UVnWc82V\",\n                \"sender\": \"76a914caee018147f2d5ff32ca3b2ef35c17755bce440e88ac\",\n                \"sender_pubkey\": \"0411d88aa37a0eea476a5b63ca4b1cd392ded830865824c27dacef6bde9f9bc53fa13a0926533ef4d20397207e212c2086cbe13db5470fd29616abd35326d33090\",\n                \"txid\": \"7cfdfcf0c0abac9641ed5e253e7ba2b3ddabbc0b15302a4fc138519dd028d3ea\",\n                \"value_hash\": \"dbbdedc2b81d875403cc76486625a19f1e3b3c6f\",\n                \"vtxindex\": 234\n            }\n        ]\n    },\n    \"importer\": \"76a9143e2b5fdd12db7580fb4d3434b31d4fe9124bd9f088ac\",\n    \"importer_address\": \"16firc3qZU97D1pWkyL6ZYwPX5UVnWc82V\",\n    \"last_renewed\": 373622,\n    \"name\": \"judecn.id\",\n    \"op\": \";\",\n    \"op_fee\": 100000.0,\n    \"opcode\": \"NAME_IMPORT\",\n    \"preorder_block_number\": 373622,\n    \"revoked\": false,\n    \"sender\": \"76a914395f3643cea07ec4eec73b4d9a973dcce56b9bf188ac\",\n    \"sender_pubkey\": \"0411d88aa37a0eea476a5b63ca4b1cd392ded830865824c27dacef6bde9f9bc53fa13a0926533ef4d20397207e212c2086cbe13db5470fd29616abd35326d33090\",\n    \"txid\": \"1510e1582f48c7ea1c57156e6ac5ae0d2c0960cfb4d17db0860e140f6900beed\",\n    \"value_hash\": \"dbbdedc2b81d875403cc76486625a19f1e3b3c6f\",\n    \"vtxindex\": 108\n}\n```\n\nIn this example, we look up a name that does not exist:\n\n```\n$ blockstore-cli get_name_blockchain_record nonexistent.id\n{\n    \"error\": \"Not found.\"\n}\n```\n\n### Listing Names\n\nBlockstore can serve a listing of all the name metadata it knows about.  To do so, the command is:\n\n```\n$ blockstore-cli get_all_names\n```","name-pricing":"# Name Pricing\n\n","name-registrations":"# Name Registrations\n","name-transfers":"# Name Transfers\n\n","namespaces":"# Namespaces\n","virtual-blockchain":"# Virtual Blockchain\n","zonefile-updates":"# Zonefile Updates\n"}