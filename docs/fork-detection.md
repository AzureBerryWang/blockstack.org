# Fork Detection

Due to their decentralized nature, proof-of-work blockchains like Bitcoin's cannot not guarantee write stability.  At any given point in time, there can be multiple blockchain _forks_--different blockchains worked on by disjoint sets of peers that diverge at a particular block.  This can happen if there is a network partition between two or more sets of peers, or if two sets of peers discover a different block for the same height at about the same time (Figure 5).

The way blockchain peers resolve diverging forks is to always attempt to work on the blockchain with the highest proof-of-work (i.e. the fork that cost the most energy to produce), and to discard all other forks.  This means that if a blockchain peer submits a transaction, it is possible for the peer to witness the transaction get incorporated into a block, but then later discard the block if the block was later discovered to be on a fork.

![Blockchain fork event timeline](/images/docs/blockchain-fork.png)

_Figure 5:  Timeline of events when the blockchain encounters a fork.  The transaction tx2 gets incorporated into a block on a fork that is later discarded.  As a result, only tx1 will appear on the blockchain with the most proof-of-work._

The consequence for Blockstore is that name operations can get lost if they are incorporated onto a minority fork.  This will lead to a divergence in the Blockstore peers' consensus hashes, since some peers will process name operations on a minority fork while others will not.  This is particularly devistating to name registrars that broadcast many name operations in a small amount of time, because they stand to lose a large number of transactions.  The challenge is to provide a way to quickly and automatically detect and resolve consensus hash divergences due to blockchain forks, in order to minimize the amount of time required to recover and minimize the number of lost transactions.

Fortunately, if the current block height is `h`, then the probability that the block at height `h - k` is on a fork decreases exponentially as a function of `k`.  As a result, Blockstore can avoid most forks simply by processing blocks only if they are at least `k` blocks lower than the highest block in the blockchain.  However, this does not eliminate the threat of forks.

![Blockchain fork detection and recovery](/images/docs/fork-recovery.png)

_Figure 6:  Schematic of Blockstore peer and backup peer deployments.  When a Blockstore peer detects disagreement in its consensus hash (1), it queries back-up peers until it finds an agreeing consensus hash (2).  From there, it fetches a copy of the back-up peer's database (3) and catches itself up to block `h - k`.  Blockstore operators that process many name operations back up successfully-sent operations to an indepedent, durable database (in green), so they can be replayed if all Blockstore nodes diverge._

The solution to detecting forks is to configure a set of mutually-trusting Blockstore peers to fetch the blockchain from different sources, and configure the peers to check every time a new block is discovered to see if they all agree on the same consensus hash at height `h - k` (Figure 6).  If they do not, then a fork at least `k` blocks long has occurred, and each peer needs to check with the backups to see if it diverged.  If it diverged, then it needs to roll back its database to the block height where it diverged, and re-download the blockchain to re-converge on the correct consensus hash.

To faciliate recover, a Blockstore peer operator runs an additional set of private, back-up Blockstore peers that process blocks up to heights `h - k - 2^i`, for all positive integers `i` such that `h - k - 2^i >= h0`.  These peers are not meant to be publicly reachable, but instead curate prior states of all name and namespace records, and serve as recovery checkpoints for the public set of peers processing blocks at height `h - k`.  If a peer processing at height `h - k` detects that it could be on a fork, it works backwards from the consensus hash at found at height `h - k` to find a consensus hash at height `h - k - 2^i` where it still agrees with a back-up peer.  In particular, it checks each consensus hash down from `h - k` in a linear fashion, and selects the peer with the largest `h - k - 2^i` that has a consensus hash that agrees.  Once found, the peer fetches a copy of the back-up peer's database, authenticates it (if the back-up peer is not trusted), and then re-builds the database up to height `h - k` by downloading the missing blocks from the blockchain.

The distribution of block heights the back-up peers follow was chosen to balance the number of blocks a peer will need to re-download on recovery against the likelihood of having to recover from a fork of a particular length.  The number of blocks a peer must re-download on recovery from a fork at height `h - d` is minimized when there is a back-up peer with a database at `h - d`.  However, it is inefficient to run `h0 - h` back-up peers, and most forks are expected to resolve in less than `k` blocks (those that don't are much more likely to resolve at depth `d` than at `d+1`).  Selecting a power-of-2 distribution of back-up peer height intervals ensures that a recovering peer will not download more than twice the number of blocks than the minimum number required, while also ensuring that the number of necessary back-up peers grows logarithmically with the blockchain height.  In addition, the interval distribution places most back-up peers close to `h - k`, which we expect to cover nearly all of the fork recovery scenarios for forks greater than `k` blocks.

It must be noted that this fork detection and recovery protocol only guarantees that the set of Blockstore peers are on the same fork; it does not guarantee that they are always on the majority blockchain fork, since it is possible for every Blockstore peer and corresponding blockchain peer to be on a minority fork.  The distribution of Blockstore peers and the blockchain peers they communicate with must be kept diverse, in order to minimize the chance of this happenning.  To prepare for this scenario, the Blockstore peer operator (e.g. a registrar) should replicate each processed name operation, independent of Blockstore peers, so they can be re-submitted once the fork resolves and the Blockstore peers are recovered.